### Наследование
Существует два подхода - это наследование и композиция.
#### Наследование(is a)
Прежде всего, наследование - это значит, что наш класс-наследник - это класс, который является тем же, что и родитель, т.е это - `is a`.
У него те же свойства и параметры, он только расширяет родителя, но никак не сужает его возможности.
Если наш класс не удовлетворяет принципу `is a` - то применять здесь наследование - **ошибочно**.
Т.е если у нас есть класс `User` и класс `Admin` или там класс `Figure` и класс `Rectangle`, то тут применение наследования - верный путь, true.

Плюсы наследования:
* Повторное использование уже существующих и протестированных участков кода
* Выстраиваемая иерархия наследников

Минусы наследования:
* Дочерний класс зависит от изменений в родительском классе, изменив что-то в родительском - мы автоматически получаем эти изменения в дочернем.
Пусть у нас есть своя какая-то `MyHashMap` и мы отнаследовали ее от `HashMap`, переопределили метод `add(...)`,
если разработчики `HashMap` введут `addAll(..)` - у нас будет в этом месте дыра, ведь мы переопределили уже `add` по-своему, но не `addAll`, который будет добавлять элементы 'по старому'.
* Ошибка в неверной иерархии наследования - и у нас огромные проблемы с расширением нашего кода в дальнейшем.

Использовать наследование надо крайне *аккуратно*, все время проверяя на `is a` правило.

Также стоит отметить, что при наследовании и создании дочернего класса - вызывается конструктор родительского!

Что делать, если `is a` нам не подходит?

Другой подход - это композиция

#### Композиция(has a)
Композиция - это когда класс обладает свойствами своих составных частей. Т.е мы составляем наш класс из каких-то кирпичиков. Один из способов как в Java реализовать множественное наследование.
Т.е если у нас есть, например, класс HDD и класс Notebook, то Notebook включает в себя HDD, т.е удовлетворяет `has a` принципу. Т.е это расширение функционала класса за счет 'внедрения' других классов.

В целом понятно, что мы не тащим за собой все из родительского объекта, а работаем с составными частями. Да еще и не вызываем конструкторы родительского класса при создании объекта.

Минусы такого подхода только в том, что иногда действительно удобнее работать с чистым наследованием и иерархией классов.

Наследование - это именно 'расширение' какого-то функционала, а композиция - включение(внедрение).
При наследовании мы всегда обязаны помнить про родителя, про его изменения и его поведение, поэтому часто композиция - более лучший выбор.

Стоит также отметить, что наследование довольно тяжело применить в реальной жизни, поэтому гораздо лучше использовать композицию.

#### Отличие композиции от агрегации.
Агрегация и Композиция очень похожи, поэтому новичку сложно разобраться в их разнице.

Постараемся обяснить очень простым языком:
* Композиция

  Композиция - это такой случай, когда составные части класса **не могут** существовать без
  существования класса, в который они входят.

  Это как сердце и человек, сердце - это часть человека, но отдельно от него оно не может
  существовать, не может или его существоание не имеет смысла.

* Агрегация

  Агрегация - это такой случай, когда составные части класса **могут** существовать без
  существования класса, в который они входят.

  Это как колеса и машина, колеса - это часть машины, но они вполне могут существовать без
  конкретного текущего автомобиля, мы можем заменить их на зимние или вообще продать.


Видим, что композиция - это частный случай агрегации.
