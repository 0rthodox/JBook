## Java API
### java.util.Date и java.util.Calendar.

До `Java 8`, в стандартной библиотеке существовал(и существует) класс для задания точки на временной оси - и этот класс
`java.util.Date`. Рассматривать мы его будем вместе с `java.util.Calendar` - классом использующимся для операций с временем.

`java.util.Date` появился в `Java 1.0` и так получилось, что был крайне неудачно спроектирован.
Сейчас его использование - это плохая практика.

Но в начале давайте бегло посмотрим - что из себя представляет данный класс,
а после - опишем уже почему использовать его - плохой тон.


Итак, `java.util.Date`.

#### `java.util.Date`

Основное поле класса - это:
```java
private transient long fastTime;
```

В данном поле хранится количество количество миллисекунд с *1 января 1970 года* - `Unix-time` в миллисекундах.
Можно считать, что `java.util.Date` - это обертка над `long`.
Из этого сразу следует - что точность определения точки на временной оси составляет 1 миллисекунду.
Т.е `java.util.Date` - по сути представляет отрезок на временной оси, отрезок длиной 1 миллисекунда.

Отметить стоит еще и тот факт, что максимальное значение `long` в `Java` - это
```java
Long.MAX_VALUE =  9223372036854775807 // так как в Java 64-битное представление
```

Поэтому вместимости данного поля хватит на **века** вперед.

##### Минусы.
Почему?
* `Date` изменяемый, что порождает много ошибок - это потоконебезопасно.
* Отсутствует поддержка часовых поясов.
* Имя класса абсолютно не отражает его сути.
* Из-за странного проектирования - сложное использование класса.

Разберем небольшой пример:
```java
Date date = new Date(2016, 12, 13, 14, 49);
```

На первый взгляд - кажется, что все нормально?
Однако в данном коде сразу два подводных камня.
1. на месте, где стоит `2016` - конструктор класса `java.util.Date` ждет *отступ от 1900 года*.
2. нумерация месяцев тут начинается с 0, поэтому месяца 12 *нет*.

Добавим к этому то, что в `Java 8` все методы данного класса помечены как `@Deprecated`.

Это пробелы именно в проектировании класса - подобное `API` запутанно, не последовательно и легко может привести к ошибкам.
Добавим к этому еще и мутабельность - получим крайне несбалансированный класс, в использовании которого легко ошибиться, эти ошибки не будут проверены на этапе компиляции - трудно уловимы, вдобавок ко всему еще и крайне *критичны*.

В связи со всем вышеописанным - пользоваться данным классом мягко говоря не удобно, поэтому в `Java 8` ввели новое `Java 8 Time Api`.

Именно поэтому в `java.util.Date` существуют методы-бриджи - для связи с новым API.
Это делается с помощью методов `Date from(Instant instant)` и `Instant toInstant()`, добавленных начиная с `Java 8`.

Необходимо еще отметить вот что - для операций со временем в `Java` существует специальный класс: `java.util.Calendar`.

#### `java.util.Calendar`.
К сожалению, странный подход к проектированию коснулся и этого класса:
1. Месяцы идут с 0.
2. Дни - начинаются с 1.
3. При установке полной даты количество миллисекунд не сбрасывается(необходим вызов специального метода), а остается равным количеству миллисекунд
с предыдущего момента или текущего времени - если не было изменения календаря.

Третий пункат означает вот что:
```java
TimeZone tz = TimeZone.getTimeZone("Europe/Moscow");

Calendar calendar = Calendar.getInstance(tz);

calendar.set(2018, Calendar.MARCH, 4, 9, 2, 11);
System.out.println(calendar.getTimeInMillis());

calendar.set(Calendar.MILLISECOND, 0);
System.out.println(calendar.getTimeInMillis());
```
И получим два разных значения - отличающиеся именно в трех последних числах - как раз из-за того, что описано в пункте 3:
```
1520143331925
1520143331000
```

Теперь должен возникнуть вопрос - откуда `java.util.Date` и `java.util.Calendar` берут свое время? Где источник?
Источником - понятное дело - выступает система.


В `Java` есть следующие методы для получения времени:
* `java.lang.System.currentTimeMills`

Из документации:
>     * @return  the difference, measured in milliseconds, between
>     *          the current time and midnight, January 1, 1970 UTC.

Что значит, что он возвращает количество миллисекунд прошедших с полночи 1 января 1970 по `UTC`.

Гарантий про многопоточность данный метод не дает - в результате перевода системных часов могут быть погрешности.
К счастью, подобных переводов часто не делают - я не сталкивался ни разу.

При создании экземпляров `java.util.Date` и `java.util.Calendar` используется именно этот метод.
Это `native` метод - реализация зависит от железа, типа и версии ОС.


* `java.lang.System.nanoTime`
Из документации:
>     * @return the current value of the running Java Virtual Machine's
>     *         high-resolution time source, in nanoseconds


Что значит, что он возвращает некоторое абстрактное количество наносекундных 'тиков'.
Это `native` метод - реализация зависит от железа, типа и версии ОС.


Исходя из описаний методов можно заключить следующее - для измерения длительности операций допустимо использовать именно `java.lang.System.nanoTime`.
Более-менее современный код именно так и работает - для примера можно посмотреть реализации интерфейса `java.util.concurrent.ExecutorService`.
В более старом коде же до сих пор иногда можно встретить использование `java.lang.System.currentTimeMills` для подобных вещей - для примера можно посмотреть на `java.lang.Thread`.


Совершенно ясно теперь, что использовать конструкции вида:
```java
event.setGeneratedDate(new Date());
event.setProcessingDate(new Date());
```

Не должны быть в вашем коде - они должны быть представлены в виде:
```java
Date now = new Date();
event.setGeneratedDate(now);
event.setProcessingDate(now);
```


Также, важно рассказать еще и то, как работать с датой, если она представлена строкой - для этой цели существуют специальные классы форматтеры, для `java.util.Date` такой форматтер - это [SimpleDateFormat](./SimpleDateFormat.md)
