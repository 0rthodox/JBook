#### Введение
> Все примеры написаны с использованием Java 8 и HotSpot JVM

Все программы написанные на `Java` транслируются в байт-код,
а уже после интерпретатор работает с полученным байт-кодом.
Однако, прежде чем интерпретировать байт-код его надо загрузить в оперативную память.
Любой класс в среде выполнения `Java` был загружен каким-либо загрузчиком.
Все классы загружаются по мере надобности, с небольшими исключениями.

Различают 3 вида загрузчиков:
* `Bootstrap` - базовый загрузчик
  Загружает внутренние классы `JDK`.
* `System ClassLoader` - системный загрузчик
  Загружает классы, пути к которым указаны в переменной окружения `CLASSPATH` или пути,
  которые указаны в командном ряде после ключей  `–classpath` или  `–cp`.
* `Extention Classloader` - загрузчик расширений
  Загружает пакеты расширений, которые располагаются в директории `<JAVA_HOME>/lib/ext` или другой директории, описанной в системном параметре `java.ext.dirs`.

Также существует возможность создания собственных загрузчиков. В таком случае наш собественный загрузчик
 должен быть отнаследован от класса `java.lang.ClassLoader`.

#### Иерархия
Загрузчики классов образуют иерархию, корнем которой является базовый загрузчки:
1. `Bootstrap`
2. `Extention Classloader`
3. `System ClassLoader`

При этом каждый загрузчик сохраняет ссылку на родительский загрузчик при инициализации, что позволяет
 делегировать загрузку родителю. Т.е он запрашивает родителя загрузить класс, *прежде* чем попробовать загрузить его
 самостоятельно.

Такой подход позволяет загружать классы тем загрузчиком, который максимально близко находится к базовому. Таким образом достигается максимальная область видимости классов. Под областью видимости подразумевается следующее: каждый загрузчик ведет учет классов, которые были им загружены. Множество этих классов и назвается областью видимости.

При этом загрузчик видит только свои классы и классы родителя и понятия не имеет о классах, которые были загружены его потомком.

Еще одно важное свойство - каждый загрузчик имеет свое пространство имен для создаваемых классов.

Т.е. если классы одинаковы и находятся в одном пакете, но загружаются разными загрузчиками - они считаются разными. Таким образом, можно например, создать два объекта синглтона.

Для того, чтобы получить загрузчик, которым был загружен класс можно воспользоваться
методом `getClassLoader()` у класса.
```java
public class ClassLoadersExample {
    public static void main(String[] args) {
        System.out.println(ClassLoadersExample.class.getClassLoader());
        System.out.println(Integer.class.getClassLoader());
    }
}
```

Что выведет на экран строку вида:
```java
sun.misc.Launcher$AppClassLoader@63947c6b
null
```
Объясним почему второй принт вывел `null` - это значит, что класс загружен базовым загрузчиком.

Таким образом процесс загрузки для `Integer` был следующим:
1. Системный загрузчик проверяет - был ли данный класс загружен ранее? Если да - то класс вернется из кэша,
если нет - то он делегирует загрузку вышестоящему родительскому классу-загрузчику.
2. Загрузчик расширений проделывает ту же процедуру
3. Базовый загрузчик загружает класс самостоятельно, так как у него нет родительского класса.

При этом, как говорилось выше, если родительскому загрузчику не получилось загрузить класс - его пробует загрузить загрузчик ниже по иерархии.

Именно поэтому поиск классов будет происходить в источниках в порядке их доверия: сначала в библиотеке `Core API` - базовым загрузчиком, потом в папке расширений - загрузчиком расширений, потом в `CLASSPATH` уже системным.

Также класс может быть загружен загрузчиком, которым мы хотим:
```java
public static Class forName(String name, boolean initialize, ClassLoader loader)
```
В качестве `name` передается полное имя класса (с указанием пакета), в качестве `loader` – требуемый загрузчик.

##### Совпадение имен классов
Какой класс будет реально загружен, если в `$JAVA_HOME/lib/ext` и в `CLASSPATH` есть классы с одинаковыми полными именами?

Из всего вышеперечисленного можно заключить, что это будет из `$JAVA_HOME/lib/ext`, а не из `CLASSPATH`.

##### Порядок загрузки из CLASSPATH
Классы загружаются в том порядке, в котором они были указаны в `CLASSPATH`. Это означает то, что при наличии двух  jar-файлов, например `Test1.jar` и `Test2.jar`, содержащие одинаковые классы и перечисленные в `CLASSPATH` как `Test1.jar;Test2.jar`, в память загрузится класс из `Test1.jar`, а класс из `Test2.jar` будет пропущен.
