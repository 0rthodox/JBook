# Интерфейс java.util.List

## Введение

Как уже было сказано во [введении](../intro.md), интерфес `java.util.List` расширяет `java.util.Collection`, добавляя туда новые методы.

Как и все интерфейсы в иерархии коллекций, `java.util.List` параметризуется.

Объявление выглядит как:

```java
public interface List<E> extends Collection<E> {
    // ...
}
```

Иногда реализации `java.util.List` называют списками или последовательностями.

Реализации `java.util.List` являются упорядоченными структурами данных, разрешающими дубликаты. 

Основные методы, которые добавляет интерфейс `java.util.List`:

* `E get(int index)`
* `void add(int index, E element)`
* `int indexOf(Object element)`
* `E remove(int index)`

Интерфейс позволяет доставать элементы списка по индексу(позиции в списке), добавлять элемент по определенному индексу и узнавать индекс элемента.

Другими словами, реализации `java.util.List` предоставляют пользователю контроль над позицией элемента в списке.

Нумерация индексов, как и у массивов, начинается с `0`.

---

**Вопрос**:

Индекс в сигнатуре метода `E get(int index)` имеет тип `int`.

Как вы думаете: с чем связано это ограничение?

Ведь существует тип `long`, который имеет более широкий диапазон принимаемых значений, однако создатели интерфейса выбрали именно `int`.

**Ответ**:

В `Java` тип `int` занимает 32 бита и максимальное возможное положительное значение - это `2147483647`.

Предположим, что вы создали список такого размера, что вам не хватает типа `int` для индекса.
Давайте навскидку прикинем размер такого списка.

В 32-х битной `JVM` размер `Integer`-а составляет `16 байт`.

При полном заполнении списка этими значениями: `16 * 2147483647 = 34359738352 байт` или `34,359738352 гигабайта`.

Получается, что даже если полностью заполнить список объектами `Integer` памяти может не хватить.

Не говоря уже о том, что итерироваться по такому размеру крайне долго и затруднительно.

Поэтому типа `int` для значений индекса у списка вполне хватает, можно даже сказать, что с запасом. 

Например, максимальный размер `java.util.ArrayList`:

```java
    /**
     * The maximum size of array to allocate.
     * Some VMs reserve some header words in an array.
     * Attempts to allocate larger arrays may result in
     * OutOfMemoryError: Requested array size exceeds VM limit
     */
    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
```

---

Еще одним интересным моментом является то, что `java.util.List` добавляет специальный итератор по списку.

### ListIterator

Интерфейс `java.util.ListIterator` предоставляет возможность вставлять и заменять элементы списка, а также производить перебор элементов в двух направлениях.

```java
public interface ListIterator<E> extends Iterator<E> {
    boolean hasNext();
    E next();
    boolean hasPrevious();
    E previous();
    int nextIndex();
    int previousIndex();
    void remove();
    void set(E e);
    void add(E e);
}
```

Это расширенный итератор, который позволяет двигаться еще и в обратном порядке.

## Реализации List

В `Java` существует 4 стандартных реализации `java.util.List`:

* `java.util.ArrayList` - на основе массива
* `java.util.LinkedList` - на основе двусвязного списка
* `java.util.Vector` - также построена на основе массива, но синхронизирована
* `java.util.Stack` - расширение `java.util.Vector`

Реализации `java.util.Vector` и `java.util.Stack` сейчас практически не используются.

Виной тому является то, что `java.util.Vector` синхронизована, из-за чего она является более медленной, чем `java.util.ArrayList` или `java.util.LinkedList`.

Вместо `java.util.Stack` же лучше использовать реализации `java.util.Dequeue`.

Поэтому сосредоточим свое внимание на первых двух:

* Подробнее про [ArrayList](./ArrayList.md)
* Подробнее про [LinkedList](./LinkedList.md)

## Выбор реализации

После ознакомления с реализациями списков в `Java` предлагаю разобрать классическую задачу с собеседований.

---

**Вопрос**:

Перед вами стоит задача: необходимо добавить в список большое(действительно большое) количество объектов.

Какую реализацию вы выебере и почему?

**Ответ**:

> Забегая вперед можно скзаать, что сейчас с `Java 8+` советуют использовать только `java.util.ArrayList`.

В более ранних версиях `Java` действительно имел место выбор между реализациями.

Главный вопрос, после которого можно выбрать реализацию: куда мы добавляем все элементы?

Если добавление идет либо в конец, либо в начало, то разумным выбором будет `java.util.LinkedList`, в то время как при добавлении в середину быстрее будет `java.util.ArrayList`.

Однако, как уже было скзаано выше, в настоящий момент предпочтительнее всегда выбирать `java.util.ArrayList`.

---