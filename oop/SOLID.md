# SOLID

## Введение

Важным шагом к пониманию как писать правильный, аккуратный и чистый код является понимание принципов `SOLID`.

Итак, `SOLID` это аббревиатура, каждой букве соответствует свой принцип:

* S - Single responsibility principle
* O - Open closed principle
* L - Liskov substitution principle
* I - Interface segregation principle
* D - Dependency inversion principle

### Single responsibility principle

> A class should have one, and only one, reason to change.

Класс/оъект/интерфейс должен выполнять только одну роль, обязанность, ответственность.
И эта роль должна быть инкапсулирована внутри объекта.

Следуя данному принципу получается слабо связанное приложение, которое будет легко модифицированно.
Так как каждый класс имеет только одну роль - значит при модификации мы будем вносить изменение только в одно место, при этом у нас будет меньше конфликтов.

KISS!

### Open/Closed principle

Класс должен быть закрыт к изменению извне, но при этом - должен иметь возможности к расширению реализации.
Т.е если у нас есть некоторый базовый класс, с публичными методами, то  основные методы должны быть закрыты на серьезные модификации с помощью `final`.

### Liskov substitution principle

При создании нескольких наследников интерфейса или абстрактного класса, то они должны себя вести себя так, как подразумевает интерфейс. Их поведение не должно серьезно отличаться.

В качестве примера можно привести класс Прямоугольник и Квадрат. Класс прямоуголник имеет методы, устанавливающие ширину и длину прямоуголника. Мы наследуем Квадрат от Прямоугольника и переопределяем методы так, что любое изменение длины длины изменяет также и ширину, и наоборот. По сути - выставляем всегда одинаковые ширину и длину для Квадрата.

Получается, что вызывая метод установить длину для квадрата - мы таким образом наршуаем поведение прямоуголника.
Мы нарушаем `Liskov substitution principle` - мы нарушили поведение базового класса .

### Interface segregation principle

Стараться везде использовать интерфейс, которые должны следовать `Single responsibility principle`.

### Dependency inversion

Объекты высокого уровня не зависят от реализации объектов низкого уровня.



Dependency injection:
1. Через конструктор
2. Через set


YAGNI, KISS, DRY принципы.

//todo
