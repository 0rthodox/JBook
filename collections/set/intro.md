# Интерфейс java.util.Set

## Введение

Как уже было сказано во [введении](../intro.md), интерфес `java.util.Set` расширяет `java.util.Collection`, но при этом не добавляет новых методов.

Реализации интерфейса `java.util.Set` гарантируют отсутствие дублирующих значений.

Так как коллекции позволяют хранить `null` значения, то реализации интерфейса `java.util.Set` могут иметь не более одного такого значения.

Как и все интерфейсы в иерархии коллекций, `java.util.Set` параметризуется.

Объявление выглядит как:

```java
public interface Set<E> extends Collection<E> {
    // ...
}
```

Интерфейс `java.util.Set` описывает математическое понятие множество, отсюда и название.

Для определения того, является ли добавляемое знаечение дублем или нет, `java.util.Set` использует метод `equals`.

Поэтому крайне важно, чтобы этот метод был переопределен для элементов, с которыми планируется работа.

[Подробнее про equals](../../object/equals.md).

Важно помнить, что необходимо очень аккуратно работать с изменяемыми объектами, которые добавляются в `java.util.Set`.

## Реализации

Иерархия классов выглядит следующим образом:

<img src="../../images/collections/set_hierarchy.png">

Из рисунка видно, что в `Java` существует три наиболее популярных реализаций интерфейса `java.util.Set`:

* [java.util.HashSet](./set/hash_set.md)
* [java.util.TreeSet](./set/tree_set.md)
* [java.util.LinkedHashSet](./set/linked_hash_set.md)

### Выбор реализации

Когда и какую реализацию выбрать?

Если порядок хранения элементов не важен, то выбор `java.util.HashSet` более чем оправдан.

Данная реализация предоставляет быстрый доступ до элемента, но при условии отсутствия коллизий, т.е хорошо определенной хэш-функции добавляемых элементов, в `Java` за это отвечает метод `hashCode`.

[Подробнее про hashCode](../../object/hashCode.md).

В случае, если порядок добавления элементов важен стоит рассмотреть `java.util.LinkedHashSet`. Понятно, что за сохранение порядка надо платить, поэтому данная реализация работает медленнее, чем `java.util.HashSet`.

Если необходимо, чтобы элементы были отсортированы, то следует присмотреться к `java.util.TreeSet`. Однако в таком случае добавляемые элементы должны либо реализовывать интерфейс `java.lang.Comparable`, либо необходимо написать свой собственный компаратор.