# Общие советы новчикам

* [Советы по коду](#aСоветы-по-коду)
  * [Оформление кода](#Оформление-кода)
  * [Старайтесь избегать использования null](#Старайтесь-избегать-использования-null)
  * [Не открывайте API класса без необходимости](#Не-открывайте-API-класса-без-необходимости)
  * [Аккуратнее со строками](#Аккуратнее-со-строками)
  * [Исключения](#Исключения)
* [Общие советы](#Общие-советы)
  * [Будьте параноиком](#Будьте-параноиком)
  * [Отношение к работе](#Отношение-к-работе)
  * [Code Review](#Code-Review)
  * [Работа с Git](#Работа-с-Git)
  * [Думайте о данных](#Думайте-о-данных)

## Введение

В связи с тем, что часто сталкиваюсь с молодыми и начинающими разработчиками, решил написать несколько общих советов по работе, так как по моим замечаниями, часто все повторяют одни и те же ошибки.

Все, что я перечислю ниже - это примеры из моего опыта работы, то с чем я сталкивался сам и видел. Не хочу никого обидеть, а хочу указать на то, что часто мешает в работе и вам, и тем, с кем вы работаете на проекте.

## Советы по коду

### Оформление кода

Ни для кого уже не секрет, что в основном разработчик больше читает код, чем пишет его.

Ваш код будет кто-то читать и не один раз и необязательно при этом быть разработчиком популярной библиотеки.

Поэтому при написании кода старайтесь уделять больше внимания его оформлению, неймингу.

Чем легче читается ваш код вами - тем лучше. В качестве самоконтроля достаточно делать небольшие перерывы и после вернуться к написанному коду, затем спросить себя остается ли он все также понятен вам? Самый честный ответ вы получите особенно, если ненадолго выпали из контекста задачи.

Подробнее об этом читайте в разделе [Оформление](./code_style.md).

### Старайтесь избегать использования null

Очень часто можно встретить использование `null` в коде, при этом многие используют его как серебряную пулю, возвращая это значение даже тогда, когда это казалось бы не логично.

Например, рассмотрим метод, возвращающий книги по заданному автору.
Очень часто в `Java` разработчики, в случае, когда книг нет, возвращают `null`.

```java
List<Book> books = getBooksByAuthor(String author);

if (books != null) {
    // do some work
}
```

Так вот, в данном случае абсолютно не логично возвращать `null`. Нет значений - верните пустую коллекцию.

В `Java 8+` появились специальные классы, призванные помочь с этой проблемой - возвращения `null` при отсутствии значения, хотя и это не панацея.

[Подробнее про это](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html).

### Не открывайте API класса без необходимости

Посмотрите на код, приведенный ниже и постарайтесь ответить на вопрос, что в нем не так?

```java
class EventPusher {
    private Producer<String, byte[]> producer;
    private Properties props;

    EventPusher(Properties props) {
        this.props = props;
    }

    public Producer<String, byte[]> createNewProducer() {
        // some code
        producer = new Produecer<String, byte[]>(props);
    }

    public pushEvent(Event event) {
        Producer<String, byte[]> producer = createNewProducer();
        producer.send(event);
    }
}
```

Подобный код открывает путь в ад и я уже ползу по разбитому стеклу, чтобы покарать вас.

Почему?

Ведь вы открыли создание нового `producer` наружу!
Теперь любой может переопределить ваш этот метод и создавать `producer` так, как ему хочется, даже несмотря на `Properties props`, которые вроде как передаются в конструкторе.

Т.е мы создали возможность переопределить создание продюсера, хотя по архитектуре класса его поведение должно быть определено теми настройками, что мы передаем в конструкторе.

При компиляции такого кода никаких ошибок не будет, при запуске скорее всего тоже и мы просто будем передавать один конфиг, а продюсер будет писать по совсем другим настройкам. Думаете все будет прекрасно работать? Нет.

Крайне плохое решение, подверженное трудноуловимым и критическим ошибкам - просто потому, что мы открыли `API`, которое занимается внутренней логикой класса.

Пока без штрафов - впредь, будьте аккуратнее. И помните - чем более `API` класса открыто - тем больше вероятность, что все сломается.

### Аккуратнее со строками

Несмотря на кажующуся простоту и удобство, строки таят в себе большое количество опасности.

Часто можно встретить что-то подобное:

```java
if (format.equals("XML")) {
    // some code
}
```

Здесь таится сразу несколько проблем в format, значение аргумента может быть:

* Значение "xml", но в нижнем регистре.
* Значение " xml " - с проблелами в начале или в конце.

И хоть оба варианта также по логике будут означать, что работа ведется с форматом xml, но код работать будет по другому и в `if` блок не выполнение зайдет.

Для решения этих проблем в `Java` у `String` есть методы `equalsIgnoreCase`, `trim`,  `toLowerCase`, `toUpperCase`.

Работая со строками помните о регистре, о том, что пробельные и непечатные символы также влияют на результат сравнения!

> В приведенном же выше примере правильнее, как мне кажется, вообще использовать `enum`.

А еще, работая со строками, помните о [кодировках](../other/encoding.md).

### Исключения

Еще одной важной проблемой, которую я вижу, это тотальное пренебрежение или непонимание в работе с исключениями.

Исключения - это опасная штука, которая ломает поток выполнения вашей программы, может влиять на производительность, приводить к ошибкам в работе. Но при этом, огромное количество кода и библиотек построено на их использовании, а иногда они и вовсе очень удобны в использовании.

И некоторые просто не понимают как с ними работать, что выражается или в постоянном неконтролируемом генерировании исключений, или в не нужном перехвате ошибок, с помощью `catch`.

В генерировании исключений надо помнить, что исключение ломает поток выполнения программы и везде, где возможно, лучше обойтись без них.

Но если вам необходимо прервать поток выполнения, то постарайтесь подобрать наиболее близкое исключение из существующих или создайте свое.
Помните, что класс исключения описывает ошибочную ситуацию, в которой оно возникло. И худшее, что можно сделать, это сгенерировать исключение, никак не подходящее под сиутацию.

Например, при отсутствии файла по заданному пути кидать `java.util.NoSuchElementException`. Потому что путь до файла неверный, ошибся кто-то при вводе, но исключение-то говорит о том, что:

```java
/**
 * Thrown by various accessor methods to indicate that the element being requested
 * does not exist.
 *
 * @author  unascribed
 * @see     java.util.Enumeration#nextElement()
 * @see     java.util.Iterator#next()
 * @since   JDK1.0
 */
```

И это худшее, что можно сделать.

> Это был реальный пример из жизни.

Еще не очень хорошей практикой является кидать или оборачивать в исключения более широкого типа.

Например:

```java
if(passowrd.isEmpty()) {
    throw new RuntimeException("You entered empty password!");
}
```

Проблема тут в том, что выбрасывается наиболее общее исключение - `RuntimeException`.

Почему это проблема:

* Можно сузить тип исключения до `IllegalArgumentException`, ведь проблема в том, что пользователь не ввел пароль.
* На более широкое исключение сложнее реагировать, так как помимо нашего "You entered empty password!" мы можем перехватить еще какие-то возникшие `RuntimeException`, которые не ждем.

> Старайтесь использовать наиболее подходящие и узкие исключения.

При обработке исключений основное правило, которое надо запомнить, это: на исключения надо либо реагировать, либо делегировать, но никогда не игнорировать.

Если вы перехватили ошибку, то значит вы на нее `реагируете`. Не знаете как реагировать? `Делегируйте`.

В качестве примера разберем чтение из файла:

```java
    public List<String> readAll(String path) throws IOException {
        List<String> lines = new ArrayList<>();

        try (FileReader fr = new FileReader(path);
             BufferedReader br = new BufferedReader(fr)) {
            String line;
            while ((line = br.readLine()) != null) {
                lines.add(line);
            }
        }

        return lines;
    }
```

Здесь мы `делегировали` ошибку, делегировали тому, кто будет использовать наш код. И там точно также будут думать что делать с этим исключением: делегировать или реагировать.

> Главное, не забывайте закрывать ресурсы.
>
> Используйте `try-with-resources`, это позволит вам избежать многих проблем.

Почему мы не перехватили ее в `try/catch`?

Потому в данном случае непоняно как реагировать - максимум что можно сделать в этом методе, это залогировать ошибку и прокинуть ее дальше.

Точно также рассуждайте и в остальных случаях, если сгенерировалось исключение - прокидывайте его до того момента, где вы точно знаете, что с ним делать.

[Подробнее про исключения](../exceptions/exceptions.md)

## Общие советы

### Будьте параноиком

К сожалению, рано или поздно вы им станете, поэтому старайтесь не доверять, но проверять.

Обрамляйте свой код проверками, ведь даже `null` безопасен, если хорошо контролируется.

Старайтесь проверять то, что вам приходит в методы, валидируйте данные, ограничивайте области видимости и использования переменных до максимально узких.

Опять же, в `Java 8+` появились классы, типа `java.util.Objects`, которые содержат методы-валидаторы на `null`, как например `requireNonNull`.

Во вспомогательных библиотеках, типа `Guava`, есть классы-валидаторы, например, `Verify` или `Preconditions`.

Задумывайтесь о том, чтобы перенести некторые проверки прямо в `set`-ы объектов, чтобы недопустить ситуаций, когда в объект можно присвоить невалидное значение.

Разработка должна быть по `fail fast!` принципу.

### Отношение к работе

Многие начинающие разработчики очень сильно переживают и боятся выглядеть глупым, отсюда долго сидят на одном проблемном месте и боятся задвать вопросы.

Помните, что задавать вопросы - это более чем нормально. Никто не будет считать вас глупым. Как говорится, не бывает глупых вопросов - бывают глупые ответы.

Вы - часть команды и влияете на продукт. Поэтому, если вы что-то не понимаете и не спрашиваете, то оказываете негативное влияние на процесс, ведь незнанием вы можете легко навредить. А вот спросив и устранив непонимаение - вы только помогаете проекту и даже человеку, у которого вы спрашиваете совет, так как он сам, отвечая на ваши вопросы, лучше разберется в проблеме.

> Уча других учишься сам.

Однако, это не говорит о том, что по каждой проблеме и чиху вы должны идти и спрашивать сразу совет. Сначала надо обязательно попытаться разобраться в проблеме самому. Сделать несколько подходов, если не получается, перерывов.

Общего универсального рецепта - сколько времени сидеть над проблемой, прежде чем обратиться за помощью - тут нет, все довольно индивидуально.
Но над мелкими проблемами сидеть более 30 минут, мне кажется, смысла нет, так как более опытный сотрудник поможет вам быстро с маленькой проблемой. Над более серьезными задачами можно посидеть и подумать, сделать перерыв, но если в течении пары часов ничего не получается - стоит задуматься о подмоге.

Также помните, что прежде чем обратиться за помощью надо хорошо и конкретно сформулировать суть проблемы и вопрос.

Но не бойтесь спрашивать! Это абсолютно нормальная практика.
Никто в ваших интеллектуальных способностях не засомневается, скорее наоборот.

Помните, что все когда-то были, есть и будут в таком положении непонимающих.

### Code Review

Не стоит надеяться на `code review`, но относиться к нему хорошо - необходимо.

На мой взгляд, `code review` практика крайне полезная и эффективная. И если в вашей команде этой
практики нет, то возможно стоит задуматься о ее использовании и предложить руководству идею.

Если у вас есть `code review`, то это не значит, что вы можете более расслаблено писать код, рассуждая, что там если что поправят.

Помните, что люди, делающие вам `code review` - это тоже люди и они могут что-то не
заметить/пропустить, ведь им надо вникнуть не только в ваш код, но и в контекст задачи, при этом потратив на это меньше времени, чем вы.
Держите всегда в голове главное - *ЭТИ ЛЮДИ ЧИТАЮТ ВАШ КОД*, что автоматически отсылает вас к рекомендации по оформлению.

При этом, меня часто удивляет отношение многих к тому, что вам показывают на ошибку
или какую-то неточность, а иногда позиция на замечания и вовсе враждебная.

Думаю, не стоит говорить, что это - недопустимо.

Никто не хочет вас оскорбить или обидеть тем, что просит переименовать метод
или удалить вообще этот класс.

Помните, что и вашему ревьюеру тоже пользоваться вашим кода, а значит, раз вы в команде, вы не можете игнорировать его просьбы.
Либо исправляете, либо приводите свои аргументы. Но не игнорируйте.

Иногда при `code review` можно услышать, что-то типа "это вообще не мой код, я его скопировал из такого-то модуля/такой-то части проекта и ее писал Джошуа Блох и Мартин Одерски".

Помните - даже очень хорошие программисты могут ошибаться и иногда писать не очень правильно, так как они тоже люди.
Но если вы копируете его код в проект - уже вы за него в ответе и сказать, что это Одерски тут такой кусок пирога написал не выйдет.

Либо отвечайте за копипасту - либо не копируйте.

### Работа с Git

Сообщения к коммитам должны быть человекочитаемыми и описывать то, что сделано в коммите.

Если вы видите четыре подряд коммита с надписью о задаче - это ничего не говорит, а только путает.

При виде подобного в Git моя встроенная в голову Jira начинает сбоить.

```java
-- JIRA_2891

-- JIRA_2891

-- JIRA_2891

-- JIRA_2891
```

Проблемы подобного подхода:

1. С первого взгляда совершенно не ясно что это за задача и что в рамках ее выполения было сделано.
2. Абсолютно непонтяно, почему одна и та же задача в четырех коммитах подряд.
3. В случае необходимости отката задачи непонятно какой из коммитов(все?) откатывать.

Хорошим тоном будет взять за основу правило - одна задача, один коммит.
Возможно стоит сделать `rebase` своих коммитов и засквошить их в один.

Почему это хорошо?

1. Лаконичность - быстро можно понять что было сделано.
2. При ошибке легко откатить изменения - надо лишь откатить один коммит
3. При необходимости переноса задачи в другую ветку один коммит легко можно `cherry pick`-нуть.

Обычно, я стараюсь оформлять коммиты по фичам как-то так, если нет привязки задачи к Jira или не введено иных правил.

```java
feature/posts_tags_comments
- Update liquibase sql descriptions
- Add tests
- Update models and relationships between them
```

Сначала идет заголовок-описание задачи, после уже перечисление того, что было сделано.

Если вы делаете исправление ошибки, то это не `feature`, а `bugfix` или `hotfix`.

Еще одним важным правилом, которое надо стараться соблюдать, является то, что в коммите, решающим определенную задачу, не должно быть никаких изменний кода, не связанных с задачей.

Да, очень хочется по ходу еще сделать какой-то небольшой рефакторинг, но в рамках коммита по задаче старайтесь сдерживать себя.

Потому что, если в рамках обновления версии библиотеки вы вдруг проведете легкий рефакторинг пары классов, а в дальнейшем окажется, что обновление библиотеки было зря и изменения откатят, то вы потеряете и ваш код-рефакторинг.

И по сути сделаете работу зря.

Поэтому, лучше разбейте на два коммита такие изменения.

> Одна задача - один коммит.

Следование этому правилу позволит легко работать с кодом, откатывать в случае проблем изменения и все будут вас любить.

### Думайте о данных

При выполнении задачи задумывайтесь о том, с какими данными в работаете, какой реакции от вашего код ждут как при удачных раскладах, так и при неудачных.

Например, вам передается список путей до файлов со строками, а ваша задача получить один файл с общим содержимым.

В идеале все просто: склеили содержимое всех файлов и записали в результирующий файл-агрегатор.

На деле же, вы должны задать себе и другим(аналитикам, например) огромное колиечство вопросов.

Что делать, если какой-то путь до файла ошибочен и файла нет? Что делать, если часть файла удалось прочитать, а часть нет? Насколько это большие файлы? Хватит ли вам памяти просто все прочитать и склеить или надо вводить какой-то промежуточный буфер? Что за кодировка у файлов, одинаковая у всех? Какая? В какой кодировке надо получить результат?

Как видите, даже для такой, казалось бы, простой задачи требуется большое количество уточняющих вопросов, каждый из которых влияет на результат работы.

Подобных примеров огромное количество и многие ошибки связаны как раз с тем, что разработчик не думает о данных и о том, с чем работает и для чего.

Даже самый простой пример: вас просят передавать в сообщении текущую дату и первая мысль ваша должна быть в каком формате ее ждут.

Чем более дотошны вы будете, тем будет лучше для всех.

Думайте о данных, с которыми работаете и для чего вы это делаете, какой конечный результат от вас ждут.
