## Интерфейс

### Введение

Как уже говорилось в [введение в ооп](./intro.md), класс - это совокупность `поведения` и `состояния`.

Состояние - это то, какую информацию, данные хранит этот класс.
Повдеение же - это то, что мы можем ожидать при работе с классом, как с ним взаимодействовать и т.д.

В `ООП` понятию `поведение` выделена настолько большая роль, что существует специальный термин для этого - `Интерфейс`.

Если попробовать провести аналогию с реальной жизнь, то представьте себе, что вы садитесь за руль автомобиля.
Что вы видите?

Скорее всего, по крайней мере так было в 2018 году, вы увидите руль, педали, рычаг коробки переключения передач и т.д.

Другими словами - вы видите интерфейс взаимодействия с машиной.

Графическая составляющая программ не даром называется интерфейсом.
Она определяет то, как вы будете взаимодействовать с программой, как вы будете использовать функционал программы.

При этом вы можете абсолютно не знать деталей реализации этого интерфейса, какой мотор у вас используется, карбюратор у вас или инжектор, на каком языке написана программа, которой вы пользуетесь - вам это не важно.
Интерфейс позволяет вам не знать деталей реализации, а просто взаимодействовать с объектом.

Точно тоn же принцип используется и в программировании!

Если перенести эту мысль в область программирования, то можно сказать, что интерфейс определяет то, как мы можем использовать объект.
Другими словами:
    `Интерфейс` - это определение функциональности, в виде определния методов и свойств, без каких либо привязок к особенностям класса.

Теперь давайте продемонстрируем ту гибкость, которую вам предоставляют интерфейсы. Для этого мы снова заглянем в святая святых - `JDK`.

### Гибкость

Для демонстрации гибкости интерфейсов в `Java` мы возьмем коллекции.
Одна из самых известны и часто применяемых коллекций в программировании - это список, от английского `list`.

Спиисок — это абстрактный тип данных, представляющий собой упорядоченный набор значений, в котором некоторое значение может встречаться более одного раза.

> Подробнее про списки: [Википедия](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0))

Существует несколько видов реализации списка.
В `Java` наиболее популярны две реализации: связные списки - `java.util.LinkedList` и списки, основанные на массивах, это уже `java.util.ArrayList`.

Обе структуры являются списками, они представляют собой упорядоченный набор значений, каждый элемент может встречаться более одного раза.
Однако, то **как** они хранят эти значения - различно.

Но то, **что** они делают - одинаково, они хранят элементы в порядке добавления, мы можем достать оттуда элемент, удалить и т.д.

Наверное вы уже начали догадываться - и `java.util.LinkedList`, и `java.util.ArrayList` предоставляют нам один интерфейс взаимодействия.
Этим интерфейсом является `java.util.List`.

Благодаря этому можно писать более гибкий и общий код, например, вы хотите распечатать список строк.

```java
void print(List<String> lst) {
    for(String s : lst) {
        System.out.println(s);
    }
}

void print2(ArrayList<String> lst) {
    for(String s : lst) {
        System.out.println(s);
    }
}
```

Благодаря указанию в качестве параметра интерфейса мы можем передать в `print` любой список строк - и `java.util.ArrayList`, и `java.util.LinkedList`, и собственную реализацию.
В то время как в метод `print2` мы можем передать только `ArrayList`-ы.

Если опять же провести аналогию с реальным миром, то представьте себе автомойку.
В первом случае, наша автомойка принимает все объекты, которые являются автомобилями.
Во втором - автомойка может работать только с автомобилем `ВАЗ-2109`.

Пока вы ездите на `ВАЗ-2109` или пользуетесь `LinkedList` для вас разницы в использовании `print` и `print2` нет, однако как только вы захотите использовать что-то другое, то вам потребуется уже искать новую автомойку/переписывать `print2`.

В первом же случае - вам ничего делать не надо - начали ездить на `Alfa Romeo`/использовать `ArrayList` - никаких телодвижений не надо, все уже готово.

Или представьте себе любимую программу, `сапер` или `блокнот`, например. 
Если завтра `блокнот` будет переписан на `Java` или `Python`, а интерфейс не изменится - вы об этом даже не узнаете!

В этом и заключается та универсальность и мощь применения интерфейсов.
Если вы пользуетесь интерфейсами - вы абстрагируетесь от реализации, поэтому когда у вас эта реализация изменится, то вам не потребуется переписывать вашу программу, ведь интерфейс не изменился.

Поэтому везде, где возможно, старайтесь передавать и возвращать именно интерфейсы.

Теперь, когда мы проговорили полезность интерфейсов, давайте посмотрим как ими пользоваться в `Java`.

### Использование

Как вы уже знаете, ключевое слово `extends` используется для наследования классов.
Однако, интерфейс - это не совсем класс. Интерфейс - это поведение, поэтому интерфейс **реализуют**.

Для того, чтобы реализовать интерфейс используется ключеове слово `implements`.

```java
interface Logging  {
    void log();
}

class Test implements Logging {
    @Override
    public void log() {
        System.out.println("Logging");
    }
}
```

В отличии от наследования, можно реализовывать несколько интерфейсов.
Для этого после ключевого слова `implements` вы перечисляете через запятую все интерфейсы, которые реализует ваш класс:

```java
class Test implements Serializable, Cloneable {
}
```

### Создание

Для создания интерфейса используется ключевое слово `interface`, после которого идет название интерфейса, внутри которого уже идет определение методов и свойств.

```java
public interface Greeting {
    // methods
    void greeting();
}
```

Как мы уже говорили выше, интерфейс - это `поведение`, без `состояния`.
Создается только описание — доступность, возвращаемый тип и входные параметры.

Какие методы могут быть объявлены в интерфейсе:

* Абстрактные - без тела метода, `Java 7+`.
* Статические, `Java 8+`.
* С реализацией по умолчанию, `Java 8+`.
* Приватные, `Java 9+`.

По-умолчанию, все методы и свойства интерфейса имеют модификатор доступа `public`.
Что логично, учитывая что цель интерфейса - определение функционала для реализации его классом.
Поэтому весь функционал должен быть открыт для реализации.

#### Абстрактный метод

Абстрактный метод в интерфейсе не имеет реализации.
Модификатор доступа - `public`.

Является стандартным механизмом объявления функционала.

Типичный пример:

```java
public interface Greeting {
    // methods
    void greeting();
}
```

Каждый класс, реализующий интерфейс `Greeting` добавляет себе абстрактный метод `void greeting()`.
Если класс не определяет абстрактный метод, то он должен быть абстрактным классом.

Здесь тоже все логично, мы реализовали интерфейс, тем самым добавили новый метод себе, так как этот метод абстрактный, то мы либо должны его определить, либо быть абстрактным классом.

#### Статический метод

Начиная с `Java 8` стало возможно описание статического метода в интерфейсе.
Тут все как и у обычного статического метода:

```java
interface Printable {
    static void print(){
        System.out.println("Printable print!");
    }
}

public class Test {
    public static void main(String[] args) {
        Printable.print();
    }
}
```

Статические методы у интерфейса очень удобны для группирования `utility` или `factory` методов.

Если раньше такие методы выносились в отдельный класс, то теперь можно логически сгруппировать это в одном метсе, как сделано, например, в `java.util.stream.Stream`.
Там есть методы `public static<T> Stream<T> of(T t)` и подобные, необходимые для создания стримов.
Раньше нам бы потребовалось создать дополнительный класс-фабрику для подобной цели. А сейчас можно удобно сгруппировать это.

При этом, чтобы не было путаницы, в `Java` статический метод, определенный в интерфейсе можно вызвать только явно через интерфейс его содержащий.

Другими словами:

```java
interface Printable {
    static void print() {
        System.out.println("Hello there!");
    }
}

class Test implements Printable {
    public static void main(String[] args) {
        print();   // error

        Printable a = new Printable() {

        };

        a.print(); // error

        Printable.print(); // ok
    }
}
```

* Подробнее о паттерне фабрика: [тут](../patterns/factory.md)
* Подробнее статических методах: [тут](../start/static_java.md)

#### Метод с реализацией по умолчанию

В `Java 8` добавили возможность реализации метода по умолчанию, так называемой `default` реализации.
Это достигается с помощью ключевого слова `default`.

```java
public interface Greeting {
    // methods
    default void greeting() {
        System.out.println("Default greeting");
    }
}
```

Реализация по умолчанию удобна, когда большинство классов, реализующих некоторый интерфейс, будут определять некоторый метод одинаково.
И в таком случае, удобно, когда вы не копируете один и тот же кусок реализации в каждый класс, а сделали реализацию по умолчанию.

В таком случае все классы, где реализация одинакова - будут использовать то, что по умолчанию, а те классы, которым такая реализация не подходит просто переопределят ее.
Мы избежим копирования кода, при этом не потеряем в гибкости и читабельности.

#### Приватный метод

Начиная в `Java 9` добавили возможность объявления `private`-методов в интерфейсе.
Такие методы могут быть статическими и нестатическими, но они не могут иметь реализации по умолчанию.

Подобные методы могут использоваться только внутри самого интерфейса, в котором они определены.
Сделано это для упрощения написания кода, когда вам в интерфейсе надо выполнить некоторые повторяющиеся действия:

```java
public interface Logger {

    default void logInfo(String message) {
        log(message, "INFO");
    }

    default void logWarn(String message) {
        log(message, "WARN");
    }

    default void logError(String message) {
        log(message, "ERROR");
    }

    default void logFatal(String message) {
        log(message, "FATAL");
    }

    private void log(String message, String msgPrefix) {
        // Log Message with Prefix and styles etc.
    }
    // Any other abstract, static, default methods
}
```

#### Интерфейсы-маркеры

Интерфейс может быть пустым - не содержать никаких объявлений, как в примере выше.
Такие интерфейсы называются `интерфейсы-маркеры`.

Наиболее известные интерфейсы-маркеры - это `java.io.Serializable`, `java.lang.Cloneable` и `java.util.EventListener`.

Как и следует из названия, задача интерфейса-маркера сообщить о наличии определённого поведения у объектов класса, помеченного таким интерфейсом.
Не стоит принижать значение интерфейсов-маркеров просто ввиду их 'пустоты'. Они способны оказывать серьезное влияние на производные классы, как например, `java.lang.Cloneable`.

Вспомните, что при отсутствии этого маркера вызов `clone` породит ошибку `java.lang.CloneNotSupportedException`!

> О клонировании объектов можно прочесть [тут](../object/clone.md)

Но в интерфейсах мы можем описывать не только методы, но и свойства.

### Определение констант

Помимо методов в интерфейсах могут быть определены еще и константы.

```java
public interface Stateable {
    int OPEN = 1;
    int CLOSED = 0;
}
```

По умолчанию поля в интерфейсах имеют модификаторы `public static final`, и поэтому их значение доступно из любого места вашего кода.
С одной стороны, можно считать, что константа - это тоже часть интерфейса. Поэтому и сделали возможность их добавления в интерфейс.

Однако, многие разработчики стали использовать интерфейсы для хранения констант.
Я считаю это не совсем правильным подходом, так как мне кажется, что интерфейсы немного не для этого предназначены.

Более удобный способ хранения констант, как и более красивый, на мой взгляд - это [такой](../start/classes_for_static.md)

### Наследование интерфейсов

`Java` позволяет нам создать иерархию интерфейсов.
Если вы хотите отнаследовать один интерфейс от другого - вы можете использовать ключевое слово `extends`.

Т.е один интерфейс **расширяет** другой, даже с точки зрения английского языка все выглядит очень логично!

```java
interface Printable {
    void print();
}

interface Logging extends Printable {
}

class Test implements Logging {
    @Override
    public void print() {
    }
}
```

Таким образом, интерфейс `Logging` расширяет интерфейс `Printable` и приобретает его константы и методы, кроме статических.

### Множественное наследование в Java

В `Java` запрещено множественное наследование и очень часто можно встретить утверждение, что множественное наследование заменяет множественное наследование.
Так вот, я опять таки не соглашусь с этим утверждением.

Да, вы можете реализовать несколько интерфейсов и это **частично** поможет вам заменить множественное наследование.
Но давайте помнить, что наследование - это приобретенеие и **поведения**, и **состояни**.
Это наше главное правило `is a` и `has a`.

В то время как реализация интерфейса - это приобретение **только** поведения.

И то, что вы **можете частично** заменить множественное наследование с помощью интерфейсов никак не говорит о том, что это интерфейсы нужны для этого.
Гвоздь микроскопом вы тоже забить можете.

### Функциональные интерфейсы

С приходом в `Java` функционального программирования(ФП) стало необходимо как-то объявить функцию.
До этого, если вы не забыли, у нас были только методы, которые принадлежали классам.

В `Java` сделали поддержку ФП максимально по `ООП` канонам и ввели понятие функционального интерфейса.

Если у интерфейса только один абстрактный метод, то можем считать, что это функциональный интерфейс.
Его принято помечать аннотацией `@FunctionalInterface`, которая указывает компилятору, что при обнаружении второго абстрактного метода в этом интерфейсе нужно сообщить об ошибке.
При этом, `default` методов у интерфейса может быть несколько.

Для примера рассмотрим `EventHandler`:

```java
@FunctionalInterface
public interface EventHandler<T extends Event> extends EventListener {
    void handle(T event);
}
```

Этот интерфейс имеет один абстрактный метод, помечен аннотацией и является функциональным интерфейсом.
А это дает нам возможность использовать его в виде:

```java
button.setOnAction(event -> // если происходит событие
   System.out.println("Обрабатываем нажатие кнопки."));
```

Где setOnAction выглядит в виде: `void setOnAction(EventHandler<ActionEvent> value)`.

### Анонимный класс реализующий интерфейс

```java
public interface Animal {
    void say();
}

public class Test {
    public static void main(String[] args) {
        Animal animal = new Animal() {
            @Override
            public void say() {
                System.out.println("I am animal");
            }
        };
    }
}
```

### Заключение

// todo

* Использование интерфейсов дает нам гибкость в использовании кода
* Интерфейсы определяют поведение объекта, при этом не выставляя никаких требований к состоянию.
* Интерфейсы реализуются объектами, при этом используется ключевое слово `implements`
