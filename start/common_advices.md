# Общие советы новчикам

## Введение

В связи с тем, что часто сталкиваюсь с молодыми и начинающими разработчиками, решил написать несколько общих советов по работе, так как по моим замечаниями, часто все повторяют одни и те же ошибки.

Не все советы будут связаны непосредственно с кодом, часть из них будет обращена на общий подход и отношение, работе в команде и т.д.

Все, что я перечислю ниже - это примеры из моего опыта работы, то с чем я сталкивался сам и видел. Я не хочу никого обидеть, а хочу просто показать то, что часто мешает в работе и вам, и тем, с кем вы работаете на проекте.

## Советы по коду

### Оформление кода

Ни для кого уже не секрет, что в основном разработчик больше читает код, чем пишет его.

При этом, необязательно быть разработчиком популярной библиотеки - ваш код тоже кто-то будет читать и не один раз.

Поэтому при написании кода старайтесь уделять больше внимания его оформлению, неймингу.

Чем легче читается ваш код вами - тем лучше. Можно в качестве проверки делать небольшие перерывы и после перерыва возвращаться к написанному куску, смотря - остался ли он все также понятен вам, после того как вы ненадолго выпали из контекста задачи.

Подробнее об этом: [оформление](./code_style.md)

### Старайтесь избегать использования null

Очень часто можно встретить использование `null` в коде, при этом многие используют его как серебряную пулю, возвращая это значение даже тогда, когда это казалось бы не логично.

Например:

```java
List<Book> books = getBooksByAuthor(String author);

if (books != null) {
    // do some work
}
```

В данном случае абсолютно не логично возвращать `null`, если нет книг по автору.

Нет значений - верните пустую коллекцию. 

В `Java 8+` появились специальные классы, призванные помочь с этой проблемой - возвращения `null` при отсутствии значения, хотя и это не панацея.

[Подробнее про это](https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html).

### Не открывайте API класса без необходимости

Посмотрите на код, приведенный ниже и постарайтесь ответить на вопрос, что не так?

```java
class EventPusher {
    private Producer<String, byte[]> producer;
    private Properties props;

    EventPusher(Properties props) {
        this.props = props;
    }

    public Producer<String, byte[]> createNewProducer() {
        // some code
        producer = new Produecer<String, byte[]>(props);
    }

    public pushEvent(Event event) {
        Producer<String, byte[]> producer = createNewProducer();
        producer.send(event);
    }
}
```

Подобный код открывает путь в ад и я уже ползу по разбитому стеклу, чтобы покарать вас.

Почему?

Ведь вы открыли создание нового `producer` наружу!
Теперь любой может переопределить ваш этот метод и создавать `producer` так, как ему хочется, даже несмотря на `Properties props`, которые вроде как передаются в конструкторе.

Т.е мы создали возможность переопределить создание продюсера, хотя по архитектуре класса его поведение должно быть определено теми настройками, что мы передаем в конструкторе.

При компиляции такого кода никаких ошибок не будет, при запуске скорее всего тоже и мы просто будем передавать один конфиг, а продюсер будет писать по совсем другим настройкам и все будет прекрасно работать(нет).

Крайне плохое решение, подверженное трудноуловимым и критическим ошибкам - просто потому, что мы открыли `API`, которое занимается внутренней логикой класса.

Пока без штрафов - впредь, будьте аккуратнее. И помните - чем более `API` класса открыто - тем больше вероятность, что все сломается.

### Аккуратнее со строками

Несмотря на кажующуся простоту и удобство, строки таят в себе большое количество опасности.

Часто можно встретить что-то подобное:

```java
if (format.equals("XML")) {
    // some code
}
```

Здесь таится сразу несколько проблем.

* В `format` вполне может быть значение "xml", но в нижнем регистре.
* В `format` может быть значение " xml " - с проблелами в начале или в конце.

И хоть оба варианта также по логике будут означать, что работа ведется с форматом xml, но код работать будет по другому и в `if` блок не выполнение зайдет.

Для решения этих проблем в `Java` у `String` есть методы `equalsIgnoreCase`, `trim`,  `toLowerCase`, `toUpperCase`.

Работая со строками помните о регистре, о том, что пробельные и непечатные символы также влияют на результат сравнения!

> В приведенном же выше примере правильнее, как мне кажется, вообще использовать `enum`.

## Общие советы

### Будьте параноиком

К сожалению, рано или поздно вы им станете, поэтому старайтесь не доверять, но проверять.

Обрамляйте свой код проверками, ведь даже `null` безопасен, если хорошо контролируется.

Старайтесь проверять то, что вам приходит в методы, валидируйте данные, ограничивайте области видимости и использования переменных до максимально узких.

Опять же, в `Java 8+` появились классы, типа `java.util.Objects`, которые содержат методы-валидаторы на `null`, как например `requireNonNull`.

Во вспомогательных библиотеках, типа `Guava`, есть классы-валидаторы, например, `Verify` или `Preconditions`.

Задумывайтесь о том, чтобы перенести некторые проверки прямо в `set`-ы объектов, чтобы недопустить ситуаций, когда в объект можно присвоить невалидное значение.

Разработка должна быть по `fail fast!` принципу.

### Отношение к работе

Многие начинающие разработчики очень сильно переживают и боятся выглядеть глупым, отсюда долго сидят на одном проблемном месте и боятся задвать вопросы.

Помните, что задавать вопросы - это более чем нормально. Никто не будет считать вас глупым. Как говорится, не бывает глупых вопросов - бывают глупые ответы.

Вы - часть команды и влияете на продукт. Поэтому, если вы что-то не понимаете и не спрашиваете, то оказываете негативное влияние на процесс, ведь незнанием вы можете легко навредить. А вот спросив и устранив непонимаение - вы только помогаете проекту и даже человеку, у которого вы спрашиваете совет, так как он сам, отвечая на ваши вопросы, лучше разберется в проблеме.

> Уча других учишься сам.

Однако, это не говорит о том, что по каждой проблеме и чиху вы должны идти и спрашивать сразу совет. Сначала надо обязательно попытаться разобраться в проблеме самому. Сделать несколько подходов, если не получается, перерывов.

Общего универсального рецепта - сколько времени сидеть над проблемой, прежде чем обратиться за помощью - тут нет, все довольно индивидуально.
Но над мелкими проблемами сидеть более 30 минут, мне кажется, смысла нет, так как более опытный сотрудник поможет вам быстро с маленькой проблемой. Над более серьезными задачами можно посидеть и подумать, сделать перерыв, но если в течении пары часов ничего не получается - стоит задуматься о подмоге.

Также помните, что прежде чем обратиться за помощью надо хорошо и конкретно сформулировать суть проблемы и вопрос.

Но не бойтесь спрашивать! Это абсолютно нормальная практика.
Никто в ваших интеллектуальных способностях не засомневается, скорее наоборот.

Помните, что все когда-то были, есть и будут в таком положении непонимающих.

### Code Review

Не стоит надеяться на `code review`, но относиться к нему хорошо - необходимо.

На мой взгляд, `code review` практика крайне полезная и эффективная. И если в вашей команде этой
практики нет, то возможно стоит задуматься о ее использовании и предложить руководству идею.

Если у вас есть `code review`, то это не значит, что вы можете более расслаблено писать код, рассуждая, что там если что поправят.

Помните, что люди, делающие вам `code review` - это тоже люди и они могут что-то не
заметить/пропустить, ведь им надо вникнуть не только в ваш код, но и в контекст задачи, при этом потратив на это меньше времени, чем вы.
Держите всегда в голове главное - *ЭТИ ЛЮДИ ЧИТАЮТ ВАШ КОД*, что автоматически отсылает вас к рекомендации по оформлению.

При этом, меня часто удивляет отношение многих к тому, что вам показывают на ошибку
или какую-то неточность, а иногда позиция на замечания и вовсе враждебная.

Думаю, не стоит говорить, что это - недопустимо.

Никто не хочет вас оскорбить или обидеть тем, что просит переименовать метод
или удалить вообще этот класс.

Помните, что и вашему ревьюеру тоже пользоваться вашим кода, а значит, раз вы в команде, вы не можете игнорировать его просьбы.
Либо исправляете, либо приводите свои аргументы. Но не игнорируйте.

Иногда при `code review` можно услышать, что-то типа "это вообще не мой код, я его скопировал из такого-то модуля/такой-то части проекта и ее писал Джошуа Блох и Мартин Одерски".

Помните - даже очень хорошие программисты могут ошибаться и иногда писать не очень правильно, так как они тоже люди.
Но если вы копируете его код в проект - уже вы за него в ответе и сказать, что это Одерски тут такой кусок пирога написал не выйдет.

Либо отвечайте за копипасту - либо не копируйте.

### Работа с Git

Сообщения к коммитам должны быть человекочитаемыми и описывать то, что сделано в коммите.

Если вы видите четыре подряд коммита с надписью о задаче - это ничего не говорит, а только путает.

При виде подобного в Git моя встроенная в голову Jira начинает сбоить.

```java
-- JIRA_2891

-- JIRA_2891

-- JIRA_2891

-- JIRA_2891
```

Проблемы подобного подхода:

1. С первого взгляда совершенно не ясно что это за задача и что в рамках ее выполения было сделано.
2. Абсолютно непонтяно, почему одна и та же задача в четырех коммитах подряд.
3. В случае необходимости отката задачи непонятно какой из коммитов(все?) откатывать.

Хорошим тоном будет взять за основу правило - одна задача, один коммит.
Возможно стоит сделать `rebase` своих коммитов и засквошить их в один.

Почему это хорошо?

1. Лаконичность - быстро можно понять что было сделано.
2. При ошибке легко откатить изменения - надо лишь откатить один коммит
3. При необходимости переноса задачи в другую ветку один коммит легко можно `cherry pick`-нуть.

Обычно, я стараюсь оформлять коммиты по фичам как-то так, если нет привязки задачи к Jira или не введено иных правил.

```java
feature/posts_tags_comments
- Update liquibase sql descriptions
- Add tests
- Update models and relationships between them
```

Сначала идет заголовок-описание задачи, после уже перечисление того, что было сделано.

Если вы делаете исправление ошибки, то это не `feature`, а `bugfix` или `hotfix`.

Еще одним важным правилом, которое надо стараться соблюдать, является то, что в коммите, решающим определенную задачу, не должно быть никаких изменний кода, не связанных с задачей.

Да, очень хочется по ходу еще сделать какой-то небольшой рефакторинг, но в рамках коммита по задаче старайтесь сдерживать себя.

Потому что, если в рамках обновления версии библиотеки вы вдруг проведете легкий рефакторинг пары классов, а в дальнейшем окажется, что обновление библиотеки было зря и изменения откатят, то вы потеряете и ваш код-рефакторинг.

И по сути сделаете работу зря.

Поэтому, лучше разбейте на два коммита такие изменения.

> Одна задача - один коммит.

Следование этому правилу позволит легко работать с кодом, откатывать в случае проблем изменения и все будут вас любить.
