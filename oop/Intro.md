##Введение
Java у нас все-таки ООП ЯП, а значит какое-никакое введение в это самое ООП надо бы написать.
Так как тема крайне холиварная, то постараюсь лишь вкратце пройтись по основным вещам.

## ООП
Прежде всего, какие принципы ООП мы знаем? Можно спорить уже сейчас, но!
В основном, это:

* Инкапсуляция
* Наследование
* Полиморфизм

Некоторые добавляют еще и абтсракицю туда, как четвертый. А есть и те, кто еще добавляет другие принципы.
Но самые главные - это вот эти три.
О них и поговорим, так как это основные вещи, которые вы обязаны понимать.

### Наследование
Наследование - это мощный инструмент переиспользования кода.

По сути - это механизм, когда один класс наследует(перенимает) методы и свойства
другого класса(класса-родителя).

Если у нас есть два похожих класса, с идентичными методами и большинством полей,
то логично вынести общую часть кода в отдельный класс, который и будет классом-родителем.

Однако у подобного подхода существует ряд минусов, поэтому применять его надо с умом и осторожностью.

Опять же, существует два подхода - это композиция и наследование.

Подробнее про наследование и композицию:
[More about](./Inheritance.md)
### Инкапсуляция
Это контроль доступа к полям и методам класса, скрываем реализацию от внешних глаз.
Мы скрываем наши данные, чтобы их не мог кто угодно менять. И даже если могли менять - чтобы мы могли контролировать это на ошибки, т.е если у нас есть класс Person и там поле age, то мы не можем поставить отрицательный возраст.
Также мы можем реализацию какую-то изменить и ничего не испортить.

Т.е, если суммировать:
* Контроль доступа
* Контроль валидности данных
* Возможность изменения реализации

Подробнее про инкапсуляцию:
[More about](./Encapsulation.md)

### Полиморфизм
Это возможность работать с несколькими типами так, как-будто это один и тот же тип, при этом поведение каждого типа будет зависеть от реализации.

1. Дочерний класс может быть использован везде, где используется родительский класс.
2. Если дочерний класс приведен к родительскому, то доступны методы и переменные только родительского.
3. Реализация вызывается из дочернего класса(которая `@Override`)

Подробнее о каждом:

1. Т.е если у нас есть `User` и `Admin`, который тоже `User`, то мы можем везде передать и `User`, и `Admin`.
2. При касте к родительскому классу мы как бы поднимаемся по иерархии наследования вверх, поэтому работаем уже по сути с родителем.
3. Реализация методов вызывается же из дочернего, т.е если у нас есть Admin, который переопределил какие-то методы, то мы все равно вызовем эти методы, даже если приведем к User-у.

Чтобы легче понять представьте такую картинку(или нарисуйте): слева ссылки, справа объекты.

Пусть у нас есть ссылка типа `User a` и ссылка типа `Admin b`, обе ссылки указывают на объект `Admin`.
Если вызовем `a.method()` и `b.method()` - вызовется всегда method() нашего объекта, т.е Admin.
Т.е ссылки лишь показывают функционал, предоставляют api, а реализация уже вызывается из объекта.

//todo дописать про полиморфизм

### Связывание
Это относится к полиморфизму в Java.
Итак, бывает:
* Раннее связывание
* Позднее связывание

##### Раннее связывание
Это `Overloading`, происходит в compile time - это поиск подходящей сигнатуры в зависимости от параметров.

Простыми словами - это когда у нас есть несколько методов с одним именем, например, `sum()`, один принимает два аргумента, другой три, третий коллекцию.

##### Позднее связывание
Это `Overriding`, происходит уже в runtime - это поиск подходящей реализации по реальному типу объекта.

Это уже во время исполнения приложения jvm умеет искать подходящую реализацию, дочернего или родительского класса и вызывает ее.
Именно поэтому пример в разделе полиморфизма с разными типами ссылок на один и тот же объект давали такой результат.

Пример:
```java
public class PExample {
    public static void main(String[] args) {
        User user = new Admin();
        use(user);
    }

    public static void use(User user) {
        user.test();
    }
}

class User {
    public void test() {
        System.out.println("User invoke test");
    }
}

class Admin extends User {
    @Override
    public void test() {
        System.out.println("Admin invoke test");
    }
}
```

Вызовется именно метод Admin-а, и выведет на консоль: Admin invoke test.
