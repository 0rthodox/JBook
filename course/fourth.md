# Java Базовый Курс

## Занятие 4

Четвертое занятие в рамках `Java` курса.

В [прошлый раз](./second.md) мы затронули следующие темы:

* Инкапсуляция
* Абстракция
* Наследование
* Полиморфизм

На этом занятии мы обсудим коллекции в Java. Какие есть коллекции, какие операции возможны с коллекциями, какие преимущества есть относительно обычного массива

## Введение

Коллекции в Java, они же collections - это динамические структуры данных для хранения объектов. Для того, чтобы понять в чем различие

между обычным массивом и колллекциями, надо вспомнить какие ограничения задаются обычным массивом.

Предположим вам нужен массив строк, в котором планируется хранить 10 элементов, тогда для его создания будет создан массив `array` такого вида.

```java
String[] array = new String[10];
```

А что будет, если вы захотите добавить 11ый элемент в этот массив? Ошибка. Если вы попробуете обратиться к 11му элементу в массиву,

будет ошибка java.lang.ArrayIndexOutOfBoundsException. И тогда, если вам все же нужно расширить количество элементов в массиве, у вас есть два выхода: создать новый

на большее количество элементов и итеративно перенести объекты из старого массива в новый, либо воспользоваться специальным методом для копирования элементов(об этом чуть позже).

Для того, чтобы избежать такого рода сложности, как для программиста, так и для самой JVM(создание дополнительных объектов несет в себе лишние накладные расходы на

сборку мусора), были сделаны коллекции.


Коллекции появились во второй Java, и с тех пор активно используются разработчиками. С помощью коллекций достигается динамичность добавления объектов. Другими словами,

вам, как разработчику, нет необходимости заботиться о том, какого размера у вас массив, сколько объектов у вас сейчас в нем находится, и бояться получить ошибку

переполнения массива при добавлении нового элемента.


Иерархия существующих коллекций Java выглядит следующим образом:

<img src="../images/collections/collections.png">

Как видно на картинке выше, в Java есть несколько реализаций коллекций. Каждая из них выполняет свою функцию и отвечает разным требованиям, которые ставятся
перед разработчиком.

Коллекции делятся на два типа: коллекции вида "динамический массив" и вида "ключ-значение". Отсановимся пока на первом типе. Первый тип колелкций является наследником

интерфейса `java.util.Collection`, предоставляющий основной набор методов для работы с коллекциями. В свою очередь `java.util.Collection` является наследником

интерфейса `java.lang.Iterable`. С помощью интерфейса `java.lang.Iterable` появляется возможность итерироваться по объектам коллекции,таким образом такую коллекцию можно

использовать в цикле foreach.

## java.util.Collection

Как уже было сказано выше, `java.util.Collection` предоставляет основные методы работы с коллекциями в `Java`.

Взглянем на основные методы, которые есть у каждой коллекции:

* `boolean add(element)`
* `boolean remove(element)`
* `int size()`
* `boolean isEmpty()`
* `boolean contains(element)`
* `void clear()`

Как можно видеть, все главные операции с любой структурой данных присутствуют.

Разумеется, присутствуют методы, для добавления к коллекции не только одного элемента, а целого множества элементов, также как и удаления, также существует возможность удалять по некоторому предикату, но автор данного текста для краткости опустил их перечисление.

> Предикат - это некоторое условие.

Здесь все довольно обычно, кроме, возможно, `boolean add(element)`.

Дело в том, что при добавлении элемента в коллекцию метод вернет `true`, если коллекция была изменена в результате добавления. Если же текущая реализация коллекции не может содержать дубликаты и уже содержит добавляемый элемент будет возвращено значение `false`.

Еще одним интересным моментом является то, что интерфейс `java.util.Collection` **не предоставляет** метода, который достает элемент из коллекции.

Т.е интерфейс `java.util.Collection` предоставляет возможность только добавлять и удалять значения из коллекции, но не извлекать.
---
# Интерфейс java.util.List

## Введение

Как уже было сказано во [введении](../intro.md), интерфес `java.util.List` расширяет `java.util.Collection`, добавляя туда новые методы.

Как и все интерфейсы в иерархии коллекций, `java.util.List` параметризуется.

Объявление `java.util.List` выглядит как:

```java
public interface List<E> extends Collection<E> {
    // ...
}
```

Иногда реализации `java.util.List` называют списками или последовательностями.

Реализации `java.util.List` являются упорядоченными структурами данных, разрешающими дубликаты.

Основные методы, которые добавляет интерфейс `java.util.List`:

* `E get(int index)`
* `void add(int index, E element)`
* `int indexOf(Object element)`
* `E remove(int index)`

Интерфейс позволяет доставать элементы списка по индексу(позиции в списке), добавлять элемент по определенному индексу и узнавать индекс элемента.

Другими словами, реализации `java.util.List` предоставляют пользователю контроль над позицией элемента в списке.

Нумерация индексов, как и у массивов, начинается с `0`.

---
# java.util.ArrayList

Класс `java.util.ArrayList` является одной из самых популярных и часто используемых реализаций интерфейса `java.util.List`.

Данная реализация основана на массиве, но, в отличии от массивов в `Java`, `java.util.ArrayList` может динамически менять размер, а также хранить `null` значения.

Прежде всего обратим внимание на поля класса:

```java
    /**
     * Default initial capacity.
     */
    private static final int DEFAULT_CAPACITY = 10;

    /**
     * The array buffer into which the elements of the ArrayList are stored.
     * The capacity of the ArrayList is the length of this array buffer. Any
     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA
     * will be expanded to DEFAULT_CAPACITY when the first element is added.
     */
    transient Object[] elementData; // non-private to simplify nested class access

    /**
     * The size of the ArrayList (the number of elements it contains).
     *
     * @serial
     */
    private int size;
```

Количество элементов в списке хранится в переменной `size`.

Важно понимать, что `size` - это не размер массива, это именно количество элементов.

> Если представить массив как шкаф с ящиками, то размер массива - это количество ящиков,
 а количество элементов массива - это количество занятых ящиков.

Как было сказано выше, в основе реализации лежит массив.

За это отвечает поле `elementData`.

Массив имеет фиксированный размер, а значит при создании списка его надо как-то инициализировать.

Если не указать размер массива при создании объекта `java.util.ArrayList` будет создан массив размером `10`.

Это значение по-умолчанию, которое хранится в константе `DEFAULT_CAPACITY`.

Можно указать размер при создании объекта списка воспользовавшись конструктором и передав туда значение желаемого размера:

```java
public ArrayList(int initialCapacity) {
    // ...
}
```

ArrayList реализует интерфейс `java.util.List`, который, в свою очередь, является наследником интерфейса `java.util.Collection`. Поэтому они реализует основные

метод, которые есть в `java.util.Collection`, о которых было сказано выше.

Рассмотрим основные методы:

За добавление элемента в конец у `java.util.ArrayList` отвечает метод:

```java
    /**
     * Appends the specified element to the end of this list.
     *
     * @param e element to be appended to this list
     * @return <tt>true</tt> (as specified by {@link Collection#add})
     */
    public boolean add(E e) {
        ensureCapacityInternal(size + 1);  // Increments modCount!!
        elementData[size++] = e;
        return true;
    }
```

Перед тем, как вставить добавляемый элемент в список происходит проверка: достаточно ли места для вставки?

За это отвечает метод `ensureCapacityInternal`.

Т.е сначала проверяется хватает ли места для добавления нового элемента и если хватает, то просиходит добавление элемента в конец, при этом возвращается `true`, так как список изменяется.

Для достижения динамичности расширения максимального количества элементов в ArrayList используется алгоритм проверки вместимости текущего массива. Достигается это следующим образом:

* При вызове метода add внутри него идет проверка вместимости массива с помощью ensureCapacityInternal(size + 1)
* Если массив уже полон, то сначала создается новый массив, который больше в 1,5 раза, чем текущий
* Вызывается `System.arrayCopy`, который копирует старый массив в новый.
* Добавляемый элемент вставляется в новый, только что созданный и заполненный список.

Таким образом, реализация `java.util.ArrayList` из стандартной библиотеки `Java` предоставляет быстрый доступ к элементам по индексу и линейное время доступа к элементам по значению.

Благодаря использованию `native`-метода `System.arrayCopy` реализация `java.util.ArrayList` является предпочтительным выбором при необходимости использования списка.

> Ключевое слово `native` означает, что метод реализован в платформенно-зависимом коде, чаще всего на `C/C++`, и скомпонован в виде динамической библиотеки.
>
> Эта реализация зависит от `JVM`.

> Возможно, вас сейчас это напугало, но на самом деле достаточно просто понимать, что
> `native` означает лишь то, что вызываемый код, реализован не на `Java`.

Данная реализация позволяет хранить любые значения, в том числе дубликаты и `null`.