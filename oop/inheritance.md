## Наследование
### Введение
`Наследование` — это инструмент, позволяющий описать новый класс на основе уже существующего с частично или полностью заимствованной функциональностью.
Это мощный инструмент переиспользования кода и создания собственных иерархий.

Снова постараемся ответить на вопрос: Зачем вообще придумали этот инструмент?

Представим, что мы описали некоторый класс, тут нам на помощь снова придет извечный бродяга - Person.
```java
class Person {
  private int age;
  private String name;

  // some remaining code
}
```

Далее нам понадобилось создать класс Employee - работника.
Работник имеет те же черты, что и обычный Person, но вдобавок к этому он устроен на работу.

Если бы механизм наследования отсутствовал - мы были бы написали что-то подобное:
```java
class Employee {
  private int age;
  private String name;
  private String work;

  // some remaining code
}
```

И по сути все что мы сделали - это скопировали один класс и вставили его в другой, добавив, разумеется сверху еще щепотку нового функционала.
Не мне вам объяснять, что подобный подход - копирования и вставки - это пагубная, опасная и раздражающая богов привычка.

Но что если делегировать ответственность за это копирование кода и поддержание его в консистентном состоянии на `Java`?
Под консистентном состоянии я имею в виду, что при добавлении нового поля в `Person` это поле появится и у `Employee`.

Чтобы отнаследоваться от класса необходимо использовать ключевое слово `extends`.


Класс, от которого производится наследование, называется `базовым`, `родительским` или `суперклассом`.
Новый класс — `потомком`, `наследником`, `дочерним` или `производным` классом.


Перепишем теперь наш код с использованием наследования, при этом не забудем изменить и модификаторы доступа.
```java
class Person {
  protected int age;
  protected String name;

  public Person(int age, String name) {
    this.age = age;
    this.name = name;
  }

  // some remaining code
}

class Employee extends Person {
    private String address;

    public Employee(int age, String name, String address) {
        super(age, name);
        this.address = address
    }
}
```

Теперь, мало того, что код получился более компактным и мы убрали дублирование,
так еще и получилась иерархия классов, ровно та, которая нам нужна.
Person и Employee уже больше не являются двумя независимыми классами, как было в первом примере.

Для демонстрации этого мы просто создадим метод, который ждет на вход экземпляры класса Person.
Допустим, у нас реализована некая телефонная книга:
```java
class PhoneBook {
    public static void find(Person p) {
        System.out.println(p.name);
    }
}
```

Запустите следующий код в обоих случаях, про которые мы говорили.
```java
public static void main(String[] args) {
    Person p = new Person(27, "Aleksandr");
    Employee e = new Employee(27, "Aleksandr", "Sberbank");

    PhoneBook.find(p);
    PhoneBook.find(e);
}
```

В случае, когда классы не наследуют друг друга - код даже не скомпилируется, ведь телефонная книга ждет что-то, что является Person.
А в первом случае Person и Employee это два абсолютно разных класса, которые никак не связаны друг с другом.

Из примера выше можно сделать вывод, что производный класс полностью удовлетворяет спецификации родительского, однако может иметь дополнительную функциональность.
Именно поэтому мы безболезненно в телефонную книгу можем передать и Person, и Employee.


Однако, стоит понимать, что наследование - это не только инструмент для избавления от дублирования кода.
Помните, что наследование - это приобретение *и* состояния, *и* поведения класса-родителя.
### Ключевое слово this и super
Внимательный читатель сразу обратил внимание на еще одно новое ключевое слово в теле конструктора класса Employee - `super`.
А если вы присмотритесь еще внимательней, то вы увидите и ключевое слово `this`.


Так вот, `this` - это ссылка на объект, текущего класса, а `super` - ссылка на объект его родительского класса.
Само слово `super` пошло из теории множеств, где используется термин супермножество.


А значит внутри класса можно вызвать конструктор с помощью `this()`, а `super()`, следовательно, вызовет конструктор родительского класса.

Из этого следует, что если у родительского класса есть не пустой конструктор,
то при создании дочернего класса мы **обязаны** вызвать родительский конструктор, что и происходит в примере выше.

Если задуматься, то это довольно логично, ведь вы строите свой дочерний класс, который базируется на родителськом.
Нельзя построить дом, не заложив фундамент.

И `this`, и `super` — это нестатические переменные, соответственно их нельзя использовать в статическом контексте.
Переменной `this` нельзя присвоить новое значение, потому что она объявлена как `final`, что тоже очень даже логично.

Теперь стоит сказать о том, что в `Java` все классы неявно наследники `java.lang.Object`.
А значит при создании любого класса, происходит вызов родительского конструктора через `super()`.

При этом, даже если вы не создали ни одного конструктора класса, то `Java` все равно создаст конструктор пустой по умолчанию и вызовет там `super()`.
Ведь мы создаем объект класса, родительский класс которого - `java.lang.Object`.

Вообще, если вам потребовалось внутри класса вызвать конструктор, например, более расширенный, то делать это надо именно через this:
```java
class Employee extends Person {
    protected String address;

    public Employee(int age, String name, String address) {
        super(age, name);
        this.address = address;
    }

    public Employee(int age, String name) {
        this(age, name, "EMPTY");
    }
}
```

Мы создали второй конструктор, внутри которого вызываем главный - с наибольшим количеством аргументов.
Этот прием используется тогда, когда вам необходимо для каких-то полей сделать значения по умолчанию.


Для закрепления:

| Ключевое слово | Описание                                               |
|----------------|--------------------------------------------------------|
| this           | Ссылка на текущий объект                               |
| super          | Ссылка на родительский объект                          |
| this()         | Вызов конструктора без аргументов                      |
| super()        | Вызов конструктора без аргументов родительского класса |


### Множественное наследование
Снова давайте начнем с вопроса: Может ли у класса быть более одного предка?


В `Java` так сделать нельзя.

> `java.lang.Object` мы не берем в виду, так как он является родительским классом для всех.

Однако в языках программирования типа `C++`, `Python` и т.д это возможно, такой механизм называется множественным наследованием.
С одной стороны - это довольно удобно, когда вы можете отнаследоваться от нескольких предков.
Но в жизни часто множественное наследование — потенциальный источник ошибок, которые могут возникнуть из-за наличия одинаковых имен методов в предках.

На мой же взгляд, множественное наследование слишком развязывает руки разработчикам, позволяя часто не задумываться о том, что такое наследование и насколько это опасный инструмент.

Допустим, мы пишем класс Tank, описывающий боевой танк. У нашего танка есть пушка, пулемет, гусеницы и броня.
Пушка и пулемет - это тоже объекты.
И при множественном наследовании никто не запрещает нам взять и отнаследоваться от этих классов, получив при этом их функциональность.

Вы представляете весь ужас такого действия? И дело не в том, что почти наверняка оба класса оружия имеют у себя метод `fire`.

Дело в том, что наследование значит, что наш класс-наследник - это класс, который **является** - отношение `is a` - тем же, что и родитель.
У него те же свойства и параметры, он только расширяет родителя, но никак не сужает его возможности.

И в итоге при таком подходе наш Танк - это и пулемет, и пушка. А это как раз таки в корне не верно.
Танк **содержит** и пулемет, и пушку, т.е здесь уже отношение - `has a`.

На лицо - типичное нарушение абстракции.
Вспомним пример из начала этой заметки, про телефонную книгу и ужаснемся - ведь теперь везде, где можно использовать пулемет - можно использовать и танк!
А значит и рядовой боец может взять в руки танк, что даже в патриотичных странах невозможно.


Применительно к программированию - такие просчеты могут быть фатальными и разрушить всю архитектуру приложения.
Частично из-за возможности подобных ошибок в `Java` просто решали не разрешать множественное наследование.

Если вам интересно мое мнение, то я думаю, что множественное наследование не предоставляет настолько незаменимые и необходимые возможности, а потенциальных проблем, имеющих разрушительные последствия можно наплодить более чем необходмио.
Забегая вперед я скажу, что наследование в чистом виде, как оно есть, применяется не так часто, вместо него чаще пользуются `композицией`.


Об этом мы еще поговорим подробнее.

### Когда разумно наследоваться?
Выше мы разобрали пример не совсем разумного применения наследования и у вас должен возникнуть вопрос - когда можно использовать наследование, а когда нельзя?

И ответ на этот вопрос довольно прост. Если класс, который потенциальный потомок, удовлетворяет отношению `is a` к потенциальному родителю - т.е можно сказать, что он `является` тем же, что и родительский класс, то вы можете и это будет правильно использовать наследование.

Если на вопрос "является ли он тем же, что и родитель" ответ отрицательный - то использовать наследование не логично.
Вместо этого правильно использовать **композицию**.


Для примера возьмем два класса - `Figure` и `Rectangle`.

Является ли прямоуголник некоей абстрактной фигурой? Скорее всего да.
Значит, логично сделать так, что `Rectangle` является наследником `Figure`.

Теперь поговорим о том, что делать в случае, если наше отношение - это `has a`
### Отношение has a
Существует несколько видов взаимодействия объектов, объединенных под общим понятием "Has-A Relationship" или "Part Of Relationship".
Это отношение означает, что один объект является составной частью другого объекта.


Существует два подвида этого отношения: если один объект создает другой объект и время жизни составляющего объекта зависит от времени жизни целого, то это называется `композиция`,
если же один объект получает ссылку на другой объект в процессе конструирования, то это уже  `агрегация`.


В обоих случаях мы буквально составляем наш класс по кирпичикам.
Именно так, как какой-нибудь прибор состоит из деталей.

Мы не тащим за собой все из родительского объекта, а работаем только с составными частями.
Т.е это расширение функционала класса за счет **внедрения** других объектов.

#### Отличия композиции от агрегации
* Композиция

  Композиция - это такой случай, когда составные части класса **не могут** существовать без
  существования класса, в который они входят.

  Это как сердце и человек, сердце - это часть человека, но отдельно от него оно не может
  существовать, не может или его существоание не имеет смысла.

* Агрегация

  Агрегация - это такой случай, когда составные части класса **могут** существовать без
  существования класса, в который они входят.

  Это как колеса и машина, колеса - это часть машины, но они вполне могут существовать без
  конкретного текущего автомобиля, мы можем заменить их на зимние или вообще продать.


Композиция - это частный случай агрегации.
### Минусы и плюсы
#### Наследование
Плюсы:
* Повторное использование уже существующих и протестированных участков кода
* Выстраиваемая иерархия наследников

Минусы:
* Дочерний класс зависит от изменений в родительском классе, изменив что-то в родительском - мы автоматически получаем эти изменения в дочернем.

  Пусть у нас есть своя какая-то `MyHashMap` и мы отнаследовали ее от `HashMap`, переопределили метод `add(...)`,
  если разработчики `HashMap` введут `addAll(..)` - у нас будет в этом месте дыра, ведь мы переопределили уже `add` по-своему, но не `addAll`, который будет добавлять элементы 'по старому'.

* Ошибка в неверной иерархии наследования - и у нас огромные проблемы с расширением нашего кода в дальнейшем.
* Нарушение инкапсуляции.
* Тянем все проблемы и ошибки наследованного кода.
* Тяжело выстраивать правильные абстракции.

#### Композиция/Агрегация
Плюсы:
* Ситуации на подобие той, что описана выше с `MyHashMap` исключены.
* Возможность скрыть проблемы класса-родителя, создав обертку, в которой скроем недостатки API
класс-родителя.
* Легко применять и строить абстракции.

Минусы:
* Иногда действительно удобно работать с наследованием и иерархией классов.
* Если объектов-владельцев достаточно много, то создание и уничтожение вместо одного объекта двух или более может пагубно сказаться на производтельнсоти.

*Наследование* - это именно 'расширение' какого-то функционала, в то время как *композиция* - это включение(внедрение) функционала.

Существует даже правило: "Предпочитайте композицию наследованию".
###  Заключение
* Не злоупотребляйте наследованием.
> Помните про солдат, берущих в руки танки.

* Всегда задавайтесь вопросом `is a` или `has a` и только после этого делайте выбор.
* Старайтесь избегать дублирования кода применяя или композицию, или наследование.
* Думайте над полученной иерархией классов.
