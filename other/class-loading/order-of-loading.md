#### Введение
Поговорим про порядок инициализации полей класса. Для начала вспомним, что
в `Java` поля могут принадлежать как классу, так и объекту класса.

Поля принадлежащие классу - это статические поля.
Статическое поле доступно без создания экземпляра класса - а это значит, что инициализация статических полей и полей,
 принадлежащих объекту класса, происходит в разное время.

 Класс или интерфейс - T - будет инициализирован сразу перед появлением следующих ситуаций:
 1. T является классом и создаётся экземпляр T.
 2. Вызывается статический метод, объявленный в T.
 3. Присваивается значение статическому полю, объявленному в T.
 4. Используется значение статического поля T.

 Стоит отметить, что обращение к статическому полю приводит к инициализации только того класса
 или интерфейса, который объявляет это поле, даже если обращение к этому полю было по имени дочернего класса,
  дочернего интерфейса или класса, реализующего интерфейс.

Перед инициализацией класса сначала инициализируются все его суперклассы,
также как и все интерфейсы, которые объявляют `default-методы` - методы по умолчанию пояивлись в `Java 8`.

#### Типы инициализации
1. Инициаилиазция в месте объявления.
2. Инициаилизация в конструкторе.
3. Инициализация в блоке.

##### Инициаилиазция в месте объявления.
Данный тип применим как к полям класса, так и к полям объекта класса.

Пример:
```java
class Test {
    public static final int BUFFER_SIZE = 32;
    public int current = 14;
}
```

Данный тип применять следует в случаях, когда инициализация может быть произведена коротким выражением,
при этом необходимый контекст доступен.

> Лично я предпочитаю инициализацию в месте объявления применять только для статических полей.

##### Инициаилиазция в конструкторе.
Данный тип применим только для инициализации полей объекта класса - что довольно логично.

Пример:
```java
class Test {
    public int current;
    public Test(int current) {
      this.current = current;
    }
}
```

Применяется, если для инициализации нужны параметры конструктора - нужен контекст.


##### Инициализация в блоке.
Данный тип применим для полей как класса, так и объекта класса.
В данном случае объявляется целый блок кода, в котором описывается логика.

Пример:
```java
class Test {
  static List<Character> lst;
  static {
      lst = new ArrayList<Character>();
      for (char c = 'a'; c <= 'z'; c++) {
        lst.add(c);
      }
  }

  {
      System.out.println("Block init");
  }
}
```

Статический блок - выполнится при загрузке класса, что часто бывает нужно.
Также применяется тогда, когда инициализирующий код неудобно записывать одним выржением:
```java
  Map<String, String> map = new HashMap<String, String>() {{
	   put("паук",  "арахнид");
	    put("птица", "архозавр");
	     put("кит",   "зверь");
  }};
```

После рассмотрения возможных типов инициализации рассмотрим - в каком порядке она происходит.

#### Порядок инициализации
Зададим класс со всеми типами инициализации, которые были описаны выше, а для отслеживания порядка иницаилизации добавим везде выводы в консоль:
```java
public class ClassInitializationOrder {
    private static final String CONST = printAndGetStringConst();
    private String sField = printAndGetString();

    public ClassInitializationOrder(String s) {
        System.out.println(s + " in constructor initialization");
    }

    static {
        System.out.println("Static init 1");
    }

    {
        System.out.println("Block init 1");
    }

    static {
        System.out.println("Static init 2");
    }

    {
        System.out.println("Block init 2");
    }

    private static String printAndGetStringConst() {
        System.out.println("CONST initialization");
        return "CONST";
    }

    public static void main(String[] args) {
        new ClassInitializationOrder("FIRST");
        new ClassInitializationOrder("SECOND");
    }

    private String printAndGetString() {
        System.out.println("sField initialization");
        return "sField";
    }
}
```

В методе `main` мы создадим два экземпляра класса, запустим и увидим:
```
CONST initialization
Static init 1
Static init 2
sField initialization
Block init 1
Block init 2
FIRST in constructor initialization

sField initialization
Block init 1
Block init 2
SECOND in constructor initialization
```

Какие выводы мы можем сделать?

#### Вывод
Вспомним, что при первом обращении к классу идет его загрузка с помощью `ClassLoader`-а.
При загрузке класса идет инициализация всего, что относится к классу - а значит статические переменные инициализируются на данном этапе.

Отметим, что статические переменные и блоки инициализируются **строго** в порядке объявления - что мы и видим в выводе работы программы:
1. Инициализируется константа, принадлежащая классу.
2. Происходит инициализация статических блоков - также, в порядке объявления.

Итак, класс загружен `ClassLoader`-ом, теперь происходит инициализация полей, принадлежащих объекту - также, в порядке объявления.
И уже в конце, после всех инициализаций, происходит вызов конструктора.

Объясним, почему создание второго объекта класса вышло короче - 4 выведенных строчки - это произошло потому, что класс уже загружен `ClassLoader`-ом,
нет необходимости его загружать второй раз - это как минимум нелогично - когда вы хотите открыть дверь и у вас в кармане ключи - вы не идете заказывать новую копию ключей же?

Отсюда, так как статические поля и блоки уже инициализированы при загрузке класса, при создании второго объекта класса происходит инициализация только полей, принадлежащих именно этому объекту.

Для закрепления, повторим порядок:
1. Инициализация статических полей и блоков **строго** в порядке объявления.
2. Инициализация полей и блоков объекта **строго** в порядке объявления.
3. Инициализация полей в конструкторе.


#### Наследование и инициализация
Как же влияет наследование на порядок инициализации?

На самом деле - все происходит точно также, как было описано, за исключением того,
 что при наследовании необходимо(и это логично) в начале отработать с родительским классом, а уже потом - с дочерним.

 Пусть у нас есть два класса - `Parent` и `Child`, где родитель стоит выше по иерархии, а ребенок наследуется от него.
 Тогда порядок инициализации будет:
 1. Статические поля класса `Parent`
 2. Статический блок инициализации класса `Parent`
 3. Статические поля класса `Child`
 4. Статический блок инициализации класса `Child`
 5. Нестатические поля  класса `Parent`
 6. Нестатический блок инициализации класса `Parent`
 7. Конструктор класса `Parent`
 8. Нестатические поля  класса `Сhild`
 9. Нестатический блок инициализации класса `Сhild`
 10. Конструктор класса `Сhild`

 В целом - тут понятно, что в начале загружается и инициализируется класс `Parent`, после него происходит загрузка класса `Child` - класса наследника.

 Далее происходит инициализация нестатических полей и блоков - по сути создание объекта уже началось. И сначала также инициализируется родитель, а после - наследник.
