# SOLID

## Введение

Важным шагом к пониманию того, как писать правильный, аккуратный и чистый код является понимание принципов `SOLID`.

Итак, `SOLID` это акроним, каждой букве соответствует свой принцип:

* S - SRP - Single responsibility principle
* O - OCP - Open closed principle
* L - LSP - Liskov substitution principle
* I - ISP - Interface segregation principle
* D - DIP - Dependency inversion principle

В полезных ссылках вы найдете примеры кода по каждому принципу.

### Single Responsibility Principle

> A class should have one, and only one, reason to change.

Класс должен иметь только одну причину для изменения.

Каждый объ­ект дол­жен иметь одну обя­зан­ность и эта обя­зан­ность должна быть пол­но­стью инкап­су­ли­ро­вана в класс.

Следование этому принципу даст нам слабо связанное приложение, которое будет легко изменять и дорабатывать в дальнейшем.

Для примера возьмем сервис, который составляет и рассылает отчеты.

Если объединить все эти задачи в один класс, то такой класс будет иметь сразу несколько причин для изменения:

* Изменяется содержимое отчета
* Изменяется формат отчета
* Изменяется способ рассылки отчета

В таком случае, на класс возложено слишком много ответственности, а это чревато сложностями в изменнии класса в дальнейшем, в поддержке работоспособности кода, в гибкости использования и т.д.

`SRP` говорит как раз о том, что надо разнести такой класс на несколько, чтобы каждый класс занимался своей областью.

> Делегируйте ответственность!

И не забывайте: [KISS](https://ru.wikipedia.org/wiki/KISS_(%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF))!

### Open/Closed Principle

Про­грамм­ные сущ­но­сти(клас­сы, моду­ли, функ­ции и т.д.) должны быть открыты для рас­ши­ре­ния, но закрыты для изме­не­ния.

Т.е класс должен быть закрыт к изменению извне, но при этом - должен иметь возможности к расширению реализации.

Например, у нас есть интерфейс `Personality` и класс `Greeter`:

```java
public interface Personality {
    public String greet();
}
```

И

```java
public class Greeter {
    private Personality personality;

    public Greeter(Personality personality) {
            this.personality = personality;
        }

    public String greet() {
        return personality.greet();
    }
}
```

Есть разные реализации `Personality`:

```java
public class FormalPersonality implements Personality {
    public String greet() {
        return "Good evening, sir.";
    }
}
````

или

```java
public class IntimatePersonality implements Personality {
    public String greet() {
        return "Hello Darling!";
    }
}
```

Наш класс `Greeter` открыт для расширения, мы можем передать любой другой `Personality`, в зависимости от задачи. При этом сам код `Greeter` не меняется: мы можем без изменения (перекомпиляции) модуля с логикой использовать различные способы приветствия.

Т.е классы и модули должны проектироваться так, чтобы для изменения их поведения, нам не нужно было изменять их исходный код.

В этом и состоит суть `OCP` принципа.

### Liskov Substitution Principle

Этот принцип имеет сложное математическое определение, которое можно заменить на:

> Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.

Или, если совсем упростить:

> Объекты могут быть заменены их наследниками без изменения свойств программы.

В качестве примера можно взять классы `Прямоугольник` и `Квадрат`.

Класс `Прямоугольник` имеет методы, устанавливающие ширину и длину прямоуголника.

Мы наследуем  `Квадрат` от `Прямоугольника` и переопределяем методы так, что любое изменение длины длины изменяет также и ширину, и наоборот.

По сути - выставляем всегда одинаковые ширину и длину для класса `Квадрата`.

```java
class Rectangle {
    private int height;
    private int width;

    public void setHeight(int height) {
        this.height = height;
    }

    public void setWidth(int width) {
        this.width = width;
    }
}
class Square extends Rectangle {
    public void setHeight(int height) {
        this.height = height;
        this.width = height;
    }

    public void setWidth(int width) {
        this.width = width;
        this.height = width;
    }
}
```

Так вот это - **явное** нарушение `Liskov Substitution Principle`.

Мы нарушаем повдеение базового класса таким образом, так как вдруг почему-то меняется и длина, и ширина!

Получается, что вызывая метод установить длину для квадрата - мы таким образом наршуаем поведение прямоуголника.

### Interface Segregation Principle

> Many client-specific interfaces are better than one general-purpose interface.

Прин­цип раз­де­ле­ния интер­фей­сов гово­рит о том, что слиш­ком "тол­стые" интер­фейсы необ­хо­димо раз­де­лять на более малень­кие и спе­ци­фи­че­ские, чтобы кли­енты малень­ких интер­фей­сов знали только о мето­дах, кото­рые необ­хо­димы им в рабо­те.

В ито­ге, при изме­не­нии метода интер­фейса не должны меняться кли­енты, кото­рые этот метод не исполь­зуют.

Если у вас есть интерфейс `Report`, то не стоит туда вносить все возможные методы генерации отчета, например, `generatePdf`, `generateXml` и так далее.

Так как тогда всем потребуется реализовывать методы этого "толстого" интерфейса.

А большинству может вообще не понадобится `generateXml`!

Поэтому такой интерфейс лучше разбить на несколько, `XmlReport` и `PdfReport`, например.

Внимательный читатель должен уже провести аналогию с `SRP`!

### Dependency Inversion

> Depend on abstractions, not on concretions.

* Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.

* Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Старайтесь, чтобы различные модули были автономными, и соединялись друг с другом с помощью абстракции.

> Модуль верхнего уровня - модуль, работающий с бизнес-логикой.
> Чем ближе модуль к вводу/выводу, тем ниже уровень модуля.
>
> Например, работа с БД - модуль более низкого уровня, чем модуль, работающий с бизнес-логикой пользователя.

Идея состоит в том, что разделяя уровни бизнес-логики и модули нижних уровней(например, работа с БД), вы в дальнейшем сможете поменять реализацию модуля нижнего уровня без изменения кода бизнес-логики.

Например, мы знаем, что будем использовать реляционную базу данных, и выбрали `PostgreSql`.

Но какая будет схема таблиц, какие будут индексы, и т.д. сейчас решить сложно. Разделяя бизнес-логику на разные уровни с реализацией модуля по работе с БД, мы как раз добьемся необходимой гибкости.

## Дополнение

Есть еще полезные принципы, о которых также следует поговорить.

### KISS

> Keep it simple, stupid.

`KISS` — это принцип про­ек­ти­ро­ва­ния и про­грам­ми­ро­ва­ния, при кото­ром про­стота системы декла­ри­ру­ется в каче­стве основ­ной цели или цен­но­сти.

Основной посыл `KISS` в том, что не имеет смысла реа­ли­зо­вы­вать допол­ни­тель­ные функ­ции и модули, кото­рые не нужны или их исполь­зо­ва­ние крайне мало­ве­ро­ят­но.

Также, не стоит пере­гру­жать интер­фейс теми опци­я­ми, кото­рые не нужны боль­шин­ству поль­зо­ва­те­лей.

В простоте - сила.

Стоит отметить еще то, что надо опасаться неограниченно уве­ли­чи­вать уро­вень абстрак­ции, надо уметь вовремя оста­но­вить­ся.

Не стоит закладывать избыточные функции "про запас".

Не стоит тянуть в зависимостях огром­ную биб­лио­те­ку, если вам от неё нужна лишь пара функ­ций.

Старайетсь деком­по­зировать сложную, большую задачу на простые составляющие.

### DRY

> Don’t repeat yourself.

Стоит избегать дублирования кода.

Если ваш код не дублируется, то его изменение и модификация будет происходить всегда в одном месте, что сократит количество ошибок, упростит тестирование и улучшит понимаение.

### YAGNI

> You ain’t gonna need it.

Старайтесь избежать излиш­ней абстрак­ции, обходите стороной желания экс­пе­ри­мен­та "из инте­реса" и не делайте реа­ли­за­ции функ­ци­о­на­ла, кото­рый сей­час не нужен, но, по мне­нию раз­ра­бот­чи­ка, может либо вскоре пона­до­бить­ся, либо про­сто будет поле­зен, хотя в реаль­но­сти такого очень часто не про­ис­хо­дит.

## Полезные ссылки

Примеры кода по каждому принципу:

[SOLID Примеры](https://github.com/qcha/SOLID)

Принципы из дополнения:

1. [YAGNI](https://ru.wikipedia.org/wiki/YAGNI)
2. [KISS](https://ru.wikipedia.org/wiki/KISS_(%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF))
3. [DRY](https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself)