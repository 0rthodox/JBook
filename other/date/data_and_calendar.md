#### `java.util.Date` и `java.util.Calendar`.
До `Java 8`, в стандартной библиотеке существовал(и существует) класс для задания точки на временной оси - и этот класс
`java.util.Date`. Рассматривать мы его будем вместе с `java.util.Calendar` - классом использующимся для операций с временем.

`java.util.Date` появился в `Java 1.0` и был крайне неудачно спроектирован. Его использование - это плохая практика.

Но в начале давайте бегло посмотрим - что из себя представляет данный класс,
а после - опишем уже почему использовать его - плохой тон.


Итак, `java.util.Date`.

Основное поле класса - это:
```java
private transient long fastTime;
```

В данном поле хранится количество количество миллисекунд с *1 января 1970 года* - `Unix-time` в миллисекундах.
Можно считать, что `java.util.Date` - это обертка над `long`.
Из этого сразу следует - что точность определения точки на временной оси составляет 1 миллисекунду.
Т.е `java.util.Date` - по сути представляет отрезок на временной оси, отрезок длиной 1 миллисекунда.

Отметить стоит еще и тот факт, что максимальное значение `long` в `Java` - это
```java
Long.MAX_VALUE =  9223372036854775807 // так как в Java 64-битное представление
```

Поэтому вместимости данного поля хватит на **века** вперед.

##### Минусы.
Почему?
* `Date` изменяемый, что порождает много ошибок - это потоконебезопасно.
* Отсутствует поддержка часовых поясов.
* Имя класса абсолютно не отражает его сути.
* Из-за странного проектирования - сложное использование класса.

Разберем небольшой пример:
```java
Date date = new Date(2016, 12, 13, 14, 49);
```

На первый взгляд - кажется, что все нормально?
Однако в данном коде сразу два подводных камня.
1. на месте, где стоит `2016` - конструктор класса `java.util.Date` ждет *отступ от 1900 года*.
2. нумерация месяцев тут начинается с 0, поэтому месяца 12 *нет*.

Добавим к этому то, что большинство методов данного класса помечены как `@Deprecated`.


Пользоваться данным классом не совсем удобно, уже есть новое `Java 8 Time Api`,
однако в старых проектах все еще можно встретить его и знать как работать с ним полезно.

Именно поэтому в `java.util.Date` существуют методы-бриджи - для связи с новым API.
Это делается с помощью методов `Date from(Instant instant)` и `Instant toInstant()`, добавленных начиная с `Java 8`.

Необходимо еще отметить вот что - для операций со временем в `Java` существует специальный класс: `java.util.Calendar`.

#### `java.util.Calendar`.
К сожалению, странный подход к проектированию коснулся и этого класса:
1. Месяцы идут с 0.
2. Дни - начинаются с 1.
3. При установке полной даты количество миллисекунд не сбрасывается(необходим вызов специального метода), а остается равным количеству миллисекунд
с предыдущего момента или текущего времени - если не было изменения календаря.

Третий пункат означает вот что:
```java
TimeZone tz = TimeZone.getTimeZone("Europe/Moscow");

Calendar calendar = Calendar.getInstance(tz);

calendar.set(2018, Calendar.MARCH, 4, 9, 2, 11);
System.out.println(calendar.getTimeInMillis());

calendar.set(Calendar.MILLISECOND, 0);
System.out.println(calendar.getTimeInMillis());
```
И получим два разных значения - отличающиеся именно в трех последних числах - как раз из-за того, что описано в пункте 3:
```
1520143331925
1520143331000
```

Как работать с датой, представленной строковым форматом:
[SimpleDateFormat](./SimpleDateFormat.md)
