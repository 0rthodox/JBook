# Интерфейс

## Введение

Как мы уже обсуждали во [введении в ООП](./intro.md), класс - это совокупность `поведения` и `состояния`.

Состояние - это то, какую информацию, какие данные хранит этот класс.
Поведение же - это то, что мы можем ожидать при работе с классом, как с ним взаимодействовать и т.д.

В `ООП` понятию `поведение` выделена настолько большая роль, что существует специальный термин для этого - `интерфейс`.

Если приводить пример из жизни, то можно рассмотреть объект 'машина'. Состояние этого объекта - это материал, цвет, колеса, стекла и т.д

Поведение же - это возможность открыть двери, багажник, возможность передвижения, включения фар, переключения передач и т.д

Что вы видите, когда садитесь за руль?

Скорее всего, по крайней мере так было в 2018 году, вы увидите руль, педали, рычаг коробки переключения передач и т.д.

Другими словами - вы видите интерфейс взаимодействия с машиной.

Графическая составляющая программ не даром называется интерфейсом.
Она определяет то, как вы будете взаимодействовать с программой, как вы будете использовать функционал программы. То, как **ведет** себя программа.

При этом вы можете абсолютно не знать деталей реализации интерфейса.
В случае с автомобилем вы можете абсолютно не иметь представления о том, какой мотор у вас используется, карбюратор у вас или инжектор, на каком языке написана программа, которой вы пользуетесь - вам, как обычному водителю, это не важно.

> Интерфейс позволяет вам не знать деталей реализации, а просто взаимодействовать с объектом.

Точно тот же принцип используется и в программировании!

Если перенести эту мысль в область программирования, то можно сказать, что интерфейс определяет то, как мы можем использовать объект.

Другими словами:

`Интерфейс` - это определение функциональности, в виде определния методов и свойств, без каких либо привязок к особенностям класса.

Теперь давайте продемонстрируем ту гибкость, которую нам предоставляют интерфейсы. Для этого мы снова заглянем в святая святых - `JDK`.

## Гибкость

Рассмотрим гибкость, которую дает нам применение интерфейсов на примере `Java` коллекций.
Одна из самых известны и часто применяемых коллекций в программировании - это список, от английского `list`.

Спиисок — это абстрактный тип данных, представляющий собой упорядоченный набор значений, в котором некоторое значение может встречаться более одного раза.

> Подробнее про списки можно прочесть в [википедии](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BE%D0%BA_(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0))

Существует несколько видов реализации списка.
В `Java` наиболее популярны две реализации: связные списки - `java.util.LinkedList` и списки, основанные на массивах, это уже `java.util.ArrayList`.

Обе структуры являются списками, они представляют собой упорядоченный набор значений, каждый элемент может встречаться более одного раза.
Однако, то **как** они хранят эти значения - различно.

Но то, **что** они делают - одинаково, они хранят элементы в порядке добавления, мы можем достать оттуда элемент, удалить и т.д.

Наверное вы уже начали догадываться - и `java.util.LinkedList`, и `java.util.ArrayList` предоставляют нам один интерфейс взаимодействия.
Этим интерфейсом является `java.util.List`.

Благодаря этому можно писать более гибкий и общий код, например, вы хотите распечатать список строк. Вы можете написать код как построенный на использовании интерфейса, так и на использовании конкретной реализации.

```java
void print1(List<String> lst) {
    for(String s : lst) {
        System.out.println(s);
    }
}

void print2(ArrayList<String> lst) {
    for(String s : lst) {
        System.out.println(s);
    }
}
```

И тот, и другой способ будут работать.
Однако, второй вариант написания ограничивает нас.

Благодаря указанию в качестве параметра метода интерфейса мы можем передать в `print1` любой список строк - и `java.util.ArrayList`, и `java.util.LinkedList`, и собственную реализацию списка, реализующую интерфейс `java.util.List`.

В то время как в метод `print2` мы можем передать только `ArrayList`.

Чем это грозит?

Давайте опять проведем параллель с реальным миром и представим себе автомойку.

В первом случае, наша автомойка может работать со всеми автомобилями, в то время как во втором случае автомойка может работать только с автомобилем `ВАЗ-2109`.

Пока вы ездите на `ВАЗ-2109` или пользуетесь `LinkedList` для вас разницы в использовании `print1` и `print2` нет, однако как только вы захотите использовать что-то другое, то вам потребуется уже искать новую автомойку/переписывать `print2`.

При использовании же интерфейса вам ничего делать не надо, начали ездить на `Alfa Romeo`/использовать `ArrayList` - никаких телодвижений не требуется, все уже готово.
Ведь вы ждете от объекта, с которым взаимодействуете, некоторое определенное поведение и если этот объект вам его гарантирует - вам не важно, что **именно** это за объект.

В этом и заключается та универсальность и мощь применения интерфейсов.
Если вы пользуетесь интерфейсами - вы абстрагируетесь от реализации, поэтому если у вас эта реализация изменится, то вам не потребуется переписывать ваш код.

Поэтому везде, где это возможно, старайтесь пользоваться интерфейсами, передавать и возвращать их из методов, объявлять параметром класса и т.д.

Пришла пора разобраться с тем как создаются интерфейсы и какие при этом есть нюансы.

## Создание интерфейса

Для создания интерфейса используется ключевое слово `interface`, после которого идет название интерфейса, внутри которого происходит уже определение методов и свойств.

```java
public interface Greeting {
    // methods
    void greeting();
}
```

Исходя из того, что интерфейс, это `поведение` не имеющее `состояния`, можно сделать вывод, что создается только описание метода — доступность, возвращаемый тип и входные параметры.

Какие методы могут быть объявлены в интерфейсе:

* Абстрактные - без тела метода, `Java 7+`.
* Статические, `Java 8+`.
* С реализацией по умолчанию, `Java 8+`.
* Приватные, `Java 9+`.

По-умолчанию, все методы и свойства интерфейса имеют модификатор доступа `public`.

Что довольно логично ожидать, учитывая что цель интерфейса - определение функционала для реализации его классом.
Поэтому весь функционал должен быть открыт для реализации.

### Абстрактный метод

Что можно сказать об абстрактных методах в интерфейсе:

* Абстрактный метод в интерфейсе не имеет реализации.
* Модификатор доступа - `public`.
* Является стандартным механизмом объявления функционала.

Типичный пример:

```java
public interface Greeting {
    // methods
    void greeting();
}
```

Каждый класс, реализующий интерфейс `Greeting` добавляет себе абстрактный метод `void greeting()`.

Класс не обязательно должен определять все абстрактные методы реализуемого интерфейса, но в таком случае он сам должен быть абстрактным классом.

```java
public abstract class GreetingClass implements Greeting {
    // body
}
```

Здесь тоже все логично, мы реализовываем интерфейс, тем самым добавляем себе новый метод, так как этот метод абстрактный, то мы либо должны его определить, либо быть абстрактным классом.

// todo про абстрактные классы

### Статический метод

Начиная с `Java 8` стало возможно описание статического метода в интерфейсе.
Тут все также как у обычного статического метода:

```java
interface Printable {
    static void print(){
        System.out.println("Printable print!");
    }
}

public class Test {
    public static void main(String[] args) {
        Printable.print();
    }
}
```

Статические методы у интерфейса очень удобны для группирования `utility` или `factory` методов.

> Если вы не знаете что такое `factory` метод, то советую посмотреть:
>
> * Подробнее о паттерне фабрика: [тут](../patterns/factory.md)
> * Подробнее статических методах: [тут](../start/static_java.md)

Если раньше такие методы выносились в отдельный класс, то теперь можно логически сгруппировать это в одном метсе, как сделано, например, в `java.util.stream.Stream`.

Там есть методы `public static<T> Stream<T> of(T t)` и подобные, необходимые для создания стримов.

Раньше вам бы потребовалось объявить интерфес `java.util.stream.Stream`, а подобные фабричные методы вынести в отдельный класс, т.е 'размазать' эту логику на два файла.

А сейчас можно удобно сгруппировать это в одном интерфейсе.

При этом, чтобы не было путаницы, в `Java` статический метод, определенный в интерфейсе можно вызвать только явно через интерфейс его содержащий.

Другими словами:

```java
interface Printable {
    static void print() {
        System.out.println("Hello there!");
    }
}

class Test implements Printable {
    public static void main(String[] args) {
        print();   // error

        Printable a = new Printable() {

        };

        a.print(); // error

        Printable.print(); // ok
    }
}
```

### Метод с реализацией по умолчанию

В `Java 8` добавили возможность реализации метода по умолчанию, так называемой `default` реализации.

Это достигается с помощью ключевого слова `default`.

```java
public interface Greeting {
    // methods
    default void greeting() {
        System.out.println("Default greeting");
    }
}
```

Реализация по умолчанию удобна, когда большинство классов, реализующих некоторый интерфейс, будут определять метод, содержащийся в этом интерфейсе, одинаково.

И в таком случае, удобно, когда вы не копируете один и тот же кусок реализации в каждый класс, а сделали реализацию по умолчанию.

В таком случае все классы, где реализация одинакова - будут использовать то, что объявлено по умолчанию, а те классы, которым такая реализация не подходит просто переопределят ее.

Использование методов с реализацией по умолчанию позволит избежать копирования кода, при этом не теряется ни гибкость, ни читабельность.

### Приватный метод

Начиная в `Java 9` добавили возможность объявления `private`-методов в интерфейсе.

Такие методы могут быть статическими и нестатическими, но они не могут иметь реализации по умолчанию. Такие методы **обязаны** быть реализованы сразу и могут использоваться только внутри самого интерфейса, в котором они определены.

Сделано это для упрощения написания кода, когда вам в интерфейсе надо выполнить некоторые повторяющиеся действия:

```java
public interface Logger {

    default void logInfo(String message) {
        log(message, "INFO");
    }

    default void logWarn(String message) {
        log(message, "WARN");
    }

    default void logError(String message) {
        log(message, "ERROR");
    }

    default void logFatal(String message) {
        log(message, "FATAL");
    }

    private void log(String message, String msgPrefix) {
        // Log Message with Prefix and styles etc.
    }
    // Any other abstract, static, default methods
}
```

### Интерфейсы-маркеры

Интерфейс может быть пустым - не содержать никаких объявлений, как в примере выше.
Такие интерфейсы называются `интерфейсы-маркеры`.

В качестве примера можно посмотреть такие интерфейсы как `java.io.Serializable`, `java.lang.Cloneable` и `java.util.EventListener`.

Как следует из названия, задача интерфейса-маркера сообщить о наличии определённого поведения у объектов класса, помеченного таким интерфейсом.

Не стоит принижать значение интерфейсов-маркеров просто ввиду их 'пустоты'. Они способны оказывать серьезное влияние на производные классы, как например, `java.lang.Cloneable` или `java.io.Serializable`.

Классы, реализующие `java.lang.Cloneable`, например, могут использовать метод `clone`, в то время как при отсутствии этого маркера вызов `clone` породит ошибку `java.lang.CloneNotSupportedException`!

> О клонировании объектов можно прочесть [тут](../object/clone.md)

В интерфейсах мы можем описывать не только методы, но и свойства.

## Определение свойств

Помимо методов в интерфейсах могут быть определены еще и константы.

По умолчанию поля в интерфейсах имеют модификаторы `public static final`, и поэтому их значение доступно из любого места вашего кода.

С одной стороны, можно считать, что константа - это тоже часть интерфейса. Поэтому и сделали возможность их добавления в интерфейс.

```java
public interface Stateable {
    int OPEN = 1;
    int CLOSED = 0;
}
```

Эту возможность разработчики, особенно раньше, часто используют для хранения констант в интерфейсах и использование их в классах, реализующих такие интерфесы.

Этот подход имеет право на жизнь, до сих пор часто встречается, но я считаю это не совсем правильным подходом, так как мне кажется, что интерфейсы предназначены не для этого.

Более удобный способ хранения констант, как и более красивый, на мой взгляд - это [использование классов для констант](../start/classes_for_static.md)

Мы пока не сказали ничего о том как же использовать интерфейс в `Java`. Давайте это исправим?

## Использование интерфейса

Как вы уже знаете, ключевое слово `extends` используется для наследования классов.
Однако, интерфейс - это не совсем класс. Интерфейс - это только поведение, поэтому интерфейс **реализуют**.

Для того, чтобы реализовать интерфейс используется ключеове слово `implements`.

```java
interface Logging  {
    void log();
}

class Test implements Logging {
    @Override
    public void log() {
        System.out.println("Logging");
    }
}
```

В отличии от наследования, класс может реализовывать несколько интерфейсов.
Для этого после ключевого слова `implements` вы перечисляете через запятую все интерфейсы, которые реализует ваш класс:

```java
class Test implements Serializable, Cloneable {
}
```

## Множественное наследование в Java

В `Java` запрещено множественное наследование и очень часто можно встретить утверждение, что возможность реализовать несколько интерфейсов заменяет множественное наследование.
Так вот, я опять таки не соглашусь с этим утверждением.

Да, вы можете реализовать несколько интерфейсов и это **частично** поможет вам заменить множественное наследование.
Но давайте помнить, что наследование - это приобретенеие и **поведения**, и **состояни**.
Это наше главное правило `is a` и `has a`.

В то время как реализация интерфейса - это приобретение **только** поведения.

И то, что вы **можете частично** заменить множественное наследование с помощью интерфейсов никак не говорит о том, что это интерфейсы нужны для этого.
Гвоздь микроскопом вы тоже забить можете.

Подробнее про наследование прочитать можно [здесь](./interface.md)

### Ромбовидное наследование

Одна из проблем множественного наследования - это так называемая проблема [ромбовидного наследования](https://ru.wikipedia.org/wiki/%D0%A0%D0%BE%D0%BC%D0%B1%D0%BE%D0%B2%D0%B8%D0%B4%D0%BD%D0%BE%D0%B5_%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)

Если коротко описать эту проблему, то представьте, что у вас есть класс `Button`, он может одновременно наследуется от класса `Rectangle` и от класса `Clickable`.
В свою очередь, `Rectangle` и `Clickable` наследуются от класса `Object`.

Если вызвать метод `equals` для объекта `Button`, и в классе `Button` не окажется такого метода, но в классе `Object` будет присутствовать метод `equals` по-своему переопределенный как в классе `Rectangle`, так и в `Clickable`, то какой из методов должен быть вызван?

Для ее решения в каждом из языков программирования, которые поддерживают множественное наследование, используется своя стратегия.
В `C++`, например, используется виртуальное наследование, в `Python` явно определен порядок поиска таких методов в родительских классов и т.д.

В `Java` этой проблемы нет из-за отсутствия множественного наследования, но что если у вас есть два интерфейса, имеющих одно и то же описание метода?

Например:

```java
interface One {
   void hello();
}

interface Two {
   void hello();
}
```

Что тогда? Не нарушает ли это нашу идиллию и равновесие?

Абсолютно нет! Ведь как мы уже говорили, интерфейс - это **только** поведение!

И если два интерфейса имеют одно и то же описание метода, то это всего лишь говорит о том, что реализующий эти интерфейсы объект **должен** уметь это делать.
А как он будет это делать - это ответсвенность уже класса, реализующего интерфейсы.

## Наследование интерфейсов

`Java` позволяет нам создать иерархию интерфейсов.
Если вы хотите отнаследовать один интерфейс от другого - вы можете использовать ключевое слово `extends`.

Т.е один интерфейс **расширяет** другой, даже с точки зрения английского языка все выглядит очень логично!

```java
interface Printable {
    void print();
}

interface Logging extends Printable {
}

class Test implements Logging {
    @Override
    public void print() {
    }
}
```

Таким образом, интерфейс `Logging` расширяет интерфейс `Printable` и приобретает его константы и методы, кроме статических.

## Создание анонимного класса, реализующего интерфейс

К слову говоря, в `Java` существует возможность создать анонимный класс, реализующий интерфейс.
Это бывает очень удобно тогда, когда объявлять именованный класс не совсем разумно, например, он будет использоваться только один раз.
И вместо того, чтобы объявлять класс, придумывать ему имя, реализовывать у него нужный интерфейс и создавать в месте использования объект этого класса можно просто написать так:

```java
public class Test {
    public static void main(String[] args) {
        Namable helloName = new Namable() {
            @Override
            public String name() {
                return "Hello";
            }
        };
    }
}

interface Namable {
    String name();
}

```

Удобно и коротко.

## Функциональные интерфейсы

С приходом в `Java` функционального программирования(ФП) стало необходимо как-то объявить функцию.
До этого, если вы не забыли, у нас были только методы, которые принадлежали классам.

В `Java` сделали поддержку ФП максимально по `ООП` канонам и ввели понятие функционального интерфейса.

Если у интерфейса только один абстрактный метод, то можем считать, что это функциональный интерфейс.
Его принято помечать аннотацией `@FunctionalInterface`, которая указывает компилятору, что при обнаружении второго абстрактного метода в этом интерфейсе нужно сообщить об ошибке.
При этом, `default` методов у интерфейса может быть несколько.

Для примера рассмотрим `EventHandler`:

```java
@FunctionalInterface
public interface EventHandler<T extends Event> extends EventListener {
    void handle(T event);
}
```

Этот интерфейс имеет один абстрактный метод, помечен аннотацией и является функциональным интерфейсом.
А это дает нам возможность использовать его в виде:

```java
button.setOnAction(event -> // если происходит событие
   System.out.println("Обрабатываем нажатие кнопки."));
```

Где setOnAction выглядит в виде: `void setOnAction(EventHandler<ActionEvent> value)`.

## Анонимный класс реализующий интерфейс

```java
public interface Animal {
    void say();
}

public class Test {
    public static void main(String[] args) {
        Animal animal = new Animal() {
            @Override
            public void say() {
                System.out.println("I am animal");
            }
        };
    }
}
```

## Заключение

Интерфейсы определяют поведение объекта, при этом не выставляя никаких требований к состоянию.
Это позволяет абстрагироваться от реализации и ориентироваться только на поведение объекта, на то, что от него можно ждать и как с ним взаимодействовать.

Интерфейсы реализуются классами, при этом используется ключевое слово `implements`.
Класс может реализовывать более одного интерфейса, техническое ограничение на количество реализуемых интерфейсов составляет `65535`.

> Если вам мешает это ограничение - вы делаете что-то не так.

Интефрейсы могут наследоваться друг от друга, один интерфейс может иметь несколько родительских интерфейсов.

Разумеется, интерфейс не может наследоваться от класса.
Это логично, если вспомнить что класс - это и поведение, и состояние.
В то время как интерфейс - это только поведение.

С некоторой точки зрения, интерфейсы позвоялют обойти ограничение в множественном наследовании у классов.

Использование интерфейса в качестве типа переменной или параметра метода позволяет писать более поддерживаемый, гибкий и понятный код.