##Введение
Класс `java.lang.Object` является корнем иерархии классов в `Java`.
Каждый класс, **включая массивы**, является потомком `Object` - прямым или косвенным.
А значит все классы так или иначе унаследовали и методы класса.

Методы `Object`:
* `.toString()`
* `.clone()`
* `.hashCode()`
* `.wait()`
* `.notify()`
* `.notifyAll()`
* `.equals()`
* `.finalize()`
* `.getClass()`

Рассмотрим каждый:
### toString
Зачем метод нужен - понятно, для получения строкового представления объекта.
```java
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```
По умолчанию он включает имя класса и `hashCode` в hexademical представлении , разделенные "@".

В `JavaDoc` рекомендуется этот метод переопределять.

Подробнее про: [toString](./ToString.md)

### finalize()
Данный метод вызывается `GC` тогда, когда `GC` полагает, что
более не существует ссылок на объект и его можно удалить.

Может показаться, что это отличный метод, в который хорошо поместить закрытие ресурсов и прочее, что нужно освобождать/удалять при уничтожении класса. Но это **неправильно**.

И прежде всего потому что у нас нет **НИКАКИХ** гарантий, что этот метод вообще вызовется. Например, у нас где-то в коде есть забытая ссылка на объект, и все - мы про ссылку ничего не знаем, она существует и `GC` не будет удалять этот объект. А в некоторых случаях этот метод вообще не вызовется! Например, если наше приложение вдруг упадет или мы его остановим.

Еще одно **заблуждение**  - если мы в `finalize()` методе повесим процесс(ведь `GC` работает в фоне), то и наш `GC` перестанет работать.
Это тоже **не верно**.

А вот почему:
Наш `GC` не вызывает `finalize()` напрямую, а добавляет объекты в список, вызывая `java.lang.ref.Finalizer.register(Object)`. Объект класса `Finalizer` представляет собой ссылку на объект, для которого надо вызвать `finalize()`, и хранит ссылки на следующий и предыдущий `Finalizer`, формируя двусвязный список.
Вызов же `finalize()` происходит в отдельном потоке `java.lang.ref.Finalizer.FinalizerThread`, вызовы finalize идут последовательно так, как добавлялись. Поэтому, если `finalize` зависает - виснет именно `FinalizerThread`, если класс имеет пустой метод `finalize`, то объекты такого класса будут и дальше удаляться, если же метод не пуст - то добавляются в список и ждут, пока все не отвиснет или не упадет окончательно, либо мы вообще не закроем наше приложение.

Как выглядит `finalize()` в `openJDK`:
```java
protected void finalize() throws Throwable { }
```
В большинстве случаев не рекомендуется его переопределять и использовать в качестве очистки ресурсов и т.д.

Но в очень редких случаях - этот метод может помочь. Это довольно специфичные случаи, но все же, давайте рассмотрим пример.

Например, у нас объект с Weak/Soft References и мы работаем с реально большим файлом. В какой-то момент нам не хватает памяти и `GC` начинает вычищать объекты по нашим ссылкам и убирает наш объект, но мы **ОБЯЗАНЫ** закрыть наш файловый дескриптор. И вот в таком случае - переопределение метода поможет нам.
Но вместо такого можно использовать `PhantomReference`.

### getClass()
Данный класс нельзя переопределить.

Возвращает класс объекта, который содержит методы для получения информации о классе, например, имя класса.

Сигнатура метода выглядит как:
```java
public final native Class<?> getClass();
```

Используется для Reflection API.

Пример вывода имени класса:
```java
void printClassName(Object obj) {
    System.out.println("The object's" + " class is " +
        obj.getClass().getSimpleName());
}
```

Стоит отметить, что класс `java.lang.Class` содержит большое количество методов
для опеределения свойств класса.

### hashCode()
Как видно из названия - `hashCode()` вернет нам hash code объекта.
В Oracle JDK - это native method.

```java
 public native int hashCode();
```

Метод важный и часто используемый. Используется он и в сравнении объектов, и в работе с hash-таблицами(map).

Важно понимать:
Если два объекта имеют разные `hashcode` - это значит, что у нас *разные* объекты!
Однако если у двух объектов одинаковые hash code - это вовсе *не* означает еще, что это один и тот же объект.
Такая ситуация - когда разные объекты имеют одинаковые hash code - называется `collision` или коллизией.

Почему стоит всегда переопределять данный метод:
```java
class A {
   private int a;
   public A(int a) { this.a = a; }
}

//code

print(new A(4).hashCode());
print(new A(4).hashCode());
```

И получим, что два объекта с одинаковыми полями имеют разный `hashcode`. Почему? Потому что мы не переопределили  `hashCode()` метод, вызвав  native method из `Object`, который сигнализирует нам, о том, что у нас два разных объекта, что вполне логично.

Важно знать также, что `Integer` и типы обертки возвращают в качестве `hashcode` свое значение.

Подробнее про hashCode: [HashCode](./Hashcode.md)

### equals
Данный метод сравнивает два объекта и возвращает `true`, если они равны. Для примитивных типов достаточно использовать
 оператор `==`, но не для объектов.
Метод у `Object`:
```java
public boolean equals(Object obj) {
        return (this == obj);
    }
```

По-умолчанию данный метод проверяет на то, что проверяемая ссылка ссылается на этот же объект.

Подробнее про [equals](./Equals.md)

### clone
Сигнатура метода:
```java
protected native Object clone() throws CloneNotSupportedException;
```

Если класс или суперкласс реализовывает интерфейс `Cloneable`, то при использовании метода `clone()` -
получается копия существущего объекта. Данный интерфейс является интерфейсом-марекром, как `Serializable`.

Пример:
```java
public class CloneTest implements Cloneable {
    private final int i;

    public CloneTest(int i) {
        this.i = i;
    }

    public int getI() {
        return i;
    }

    public static void main(String[] args) throws CloneNotSupportedException {
        CloneTest test = new CloneTest(2);
        CloneTest cloneTest = (CloneTest) test.clone();
        System.out.println("Original : " + test + ", i = " + test.getI());
        System.out.println("Clone : " + cloneTest + ", i = " + cloneTest.getI());
    }
}
```
Реализация данного метода по умолчанию проверяет, что класс объекта должен реализовывать интерфейс `Cloneable`.
Если такой интерфейс не реализован - бросается `CloneNotSupportedException` исключение.

Подробнее про [clone](./Clone.md)
