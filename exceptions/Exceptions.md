### Введение
При работе приложения зачастую возникают нестандартные ситуации и ошибки.

Например:
* Оборвался коннект с БД
* Пользователь ввел некорректыне данные
* Не можем закрыть файл
* Не хватает памяти
* и т.д

Такие ситуации можно либо игнорировать, либо как-то реагировать на них.
Понятно, что игнорирование подобных ситуаций вообще - это путь к нестабильно
работающему и трудно понимаему приложению, ведь если мы, например,
не реагируем на ошибку ввода имени файла для обработки - наше приложение просто 'упадет'.
Поэтому необходимо как-то на такие ситуации реагировать.

Самой простой реакцией будет возвращать некоторый код ошибки - число.
А после уже как-то реагировать(интерпретировать) его.
Данный подход, например, используется в языке `C`, где 0 - это код удачного завершения.

И хоть подобный ход и имеет право на жизнь - он крайне неудобен.
Данный способ слишком немногословен, требует помнить коды ошибок(либо постоянно сверятся с документацией, описывающей их), не позволяет строить иерархию исключительных ситуаций, а также не позволяет удобно обрабатывать такие ситуации.

Поэтому в `Java` используется механизм `Exceptions` - Исключений.

В `Java` механизм `Exception` - построен на классах, которые хранят в себе некие данные о нестандартной ситуации - причину, сообщение и т.д

Рассмотрим устройство исключений в `Java` подробнее.

#### Иерархия исключений

Ниже приведена иллюстрация исключений, как можно заметить - корнем является `java.lang.Throwable`, от которого идут два класса - `java.lang.Exception` и `java.lang.Error` - это два главных класса в работе с исключительными ситуациями.
В свою очередь - `java.lang.Exception` - это родительский класс для `java.lang.RuntimeException`.

![](../images/exceptions.png)

*Картинка большая, чтобы лучше запоминалась.*

Понятно, что раз мы работаем с классами, то мы можем наследоваться от этих классов и создавать свои собственные классы исключений.
Надо понимать, что исключения - это тоже классы, т.е мы туда можем положить свою логику, методы и переменные, при необходимости.
Однако бросить исключение - это довольно дорогая операция, поэтому не надо просто так разбрасываться ими.

В `Java` исключения делятся на два типа.
Это так называемые `checked` и `unchecked` - проверяемые и непроверяемые исключения.
Ниже рассмотрим подробнее их.

Как мы видим по схеме `java.lang.Throwable` и `java.lang.Exception` - это `checked` исключения, `java.lang.RuntimeException` и `java.lang.Error` - это `unchecked`.

Теперь разберем в чем смысл разделения на проверяемые и непроверяемые исключения.
Непроверяемые исключения - это исключения времени выполнения, исключения, которые возникают прямо во время выполнения приложения.
Проверяемые исключения проверяются компилятором в `Сompile Time` - во время компиляции, это исключения, на которые мы обязаны реагировать.
В то время как непроверяемые исключения мы не обязаны явно перехватывать и обрабатывать, ну на то они и runtime:)

Надо понимать, что перехватывать мы можем все типы исключений - и проверяемые и непроверяемые.

Но тогда зачем нам столько исключений?
Разберем подробнее иерархию.

### Exceptions

* `java.lang.Exception`
Это ситуации, которые нам не подконтрольны, т.е не смогли закрыть файл, не смогли дессериализовать класс - мы ничего не можем сделать, но можем отреагировать.
Опять же мы обязаны такие исключения обрабатывать. Либо прокидывать вверх с помощью `throws`, в сигнатуру метода. Метод может декларировать сколько угодно исключений.

* `java.lang.RuntimeException`
А вот тут уже - это наши ошибки - ошибки разработчика. Т.е обращаемся к `null`, делим на ноль где-то и прочее.
Мы можем эти ошибки перехватывать, а можем пропускать.
Ловить такие ошибки постоянно - не совсем правильно наверное, так как мы можем так и не понять причину ошибок и падений.

* `java.lang.Error`
Критические ошибки, после которых мы не можем или с трудом можем продолжать работу.
Как и все остальные - мы можем такие ошибки ловить, но зачем? Ловить их можно только в случае, если мы можем или знаем как нам поступить в таких ситуациях.

Кидать мы можем тоже любые типы исключения.

Разберем в чем разница между `Error` и `Exception`.

### Error vs Exception
`Error` - это более серьезная ситуация, нежели `Exception`.
Т.е если происходит что-то такое, что мы либо не можем исправить, либо это крайне сложно починить, например, у нас закончилась память или мы вызываем несуществующий метод - то это `Error`.
Это непросто исключительная ситуация - это ситуация, в которой работоспособность всего приложения под угрозой.

Но если мы не можем закрыть файл, мы делаем какой-нибудь запрос, не можем строку к число преобразовать - это ситуации, после которых мы **можем продолжить** работать, мы можем перехватить это, обработать(например - попросить пользователя ввести еще раз число) - это `Exception`.

Т.е разница - в *логическом разделении*.

Еще раз - если мы можем продолжить работу после ошибки - это `Exception`. Если нет или мы не знаем как - это `Error`.

### Обработка исключений
Ловить и обрабатывать исключения можно с помощью конструкций `try/catch/finally`.
Тут на первый взгляд все просто - все что *может* дать нам нестандартную ситуацию - оборачиваем в `try` блок, в блоке `catch` перечисляем то, что мы ждем, т.е какие исключения мы готовы перехватить и обработать.
После чего переходим в блок `finally`.

Помните, что в `finally` мы зайдем **всегда**. При любом раскладе мы зайдем в `finally` блок.
Выполнение программы зайдет в `finally` блок даже тогда, когда в `try` стоит `return`:
```java
public class ExceptionHandling{
  public static void main(String[] args){
    try{
         return;
    }  finally {
         System.out.println("Hello from finally block");
    }
  }
}
```

Будет выведено: `Hello from finally block`.


Сразу надо сказать, что `try-catch` блок - **не транзакционный**, что это значит?
Это значит, что все что мы делали в `try` блоке до возникновения исключительной ситуации так и останется в памяти, если мы не очистим их в `finally` или `catch` блоке.

По сути именно поэтому и существует `finally` - туда, как уже было сказано выше, мы зайдем **в любом** случае.

Также, мы не можем работать с объектами из `try` блока в других блоках - почему? Потому что компилятор не может нам гарантировать, что эти объекты создались, а вдруг у вас там возник `exception`? Тогда после строчки кода, где выбросилось исключение остальные строчки кода не выполняются - следовательно возможна ситуация, когда объект не будет создан, а значит и работать с ним нельзя.

##### Try-with-resources
Еще одно важное замечание - это введение в `Java 7` конструкции `try-with-resources`.

Как уже говорилось выше - `finally` блок выполнится всегда, поэтому там чаще всего происходит какая-то логика по освобождению ресурсов, например, закрытие дескриптора файла и т.д

Однако постоянно писать освобождение ресурса крайне накладно, ведь было бы лучше, если бы мы объявили где-то логику по освобождению и автоматически ее вызывали бы, в случае необходимости.

Представим, что мы работаем с файлом и не используем `try-with-resources`, тогда чаще всего можно встретить подобный код:
```java
BufferedReader br = null;
try{
       br = new BufferedReader(new FileReader(path));
       //read from file
   } catch (IOException e){
       e.printStackTrace();
   } finally {
           try {
                  if (br != null) {
                     br.close();
                  }
               } catch (IOException ex) {
                     ex.printStackTrace();
               }
   }
```
Опять же оговорюсь, что обработка ошибок здесь - простая распечатка `stacktrace` - просто для примера.
Ясно, что здесь блок `finally` - только для освобождения ресурса и подобное придется писать каждый раз.

А теперь та же работа с файлом, но в `Java 7+`:
```java
try (BufferedReader br = new BufferedReader(new FileReader(path))) {
         //read from file
 } catch (IOException e) {
         e.printStackTrace();
 }
```

Если вы пишите на `Java 7+` - используйте именно такой подход.

Все классы, которые работают с конструкцией `try-with-resources` должны реализовывать интерфейс `AutoCloseable`:
```java
public interface AutoCloseable {
    void close() throws Exception;
}
```

Без реализации такого интерфейса ваш класс не будет работать с `try-with-resources`.

##### Catch блок
Главное, что надо помнить - расположение `catch` блоков крайне важно.
Рассмотрим такой пример.

Пусть у нас метод бросает и `IOException`, и `Exception`, мы хотим обработать обе ситуации по разному и пишем что-то типа такого:
```java
try {
  method();
} catch (Exception e) {
  //do some logic 1
} catch (IOException e) {
  //do some logic 2
}
```
После чего убеждаемся, что обработка `IOException` в данном случае недостижима. Почему?

Все дело в том, что в таком случае более широкий фильтр "отлова" установлен выше.

Это похоже на то, как мы используем сито.
Есть более широкие, есть те, что уже.
Так вот, если установить на самом верху самое узкое сито - до низа почти ничего не дойдет - ведь мы все перехватим выше.

Тот же принцип и с обработкой исключений.

Отсюда понятно, что если нам надо перехватить прямо вот **все**, то надо ловить `Throwable`:
```java
try {
  method();
} catch (Throwable t) {
  //do some logic 1
}
```

Отметим, что при таком подходе мы ловим все типы исключений -  и `RuntimeException`, и `Error`!

Ловим `RuntimeException`:
```java
try {
   String numberAsString = "one";
   Double res = Double.valueOf(numberAsString);
    } catch (RuntimeException re) {
            System.out.println("Error while convert string to double!");
    }
```

Ловим `Error`:

```java
        try {
            throw new Error();
        } catch (RuntimeException re) {
            System.out.println("RuntimeException");
        } catch (Error error) {
            System.out.println("ERROR");
        }
    }
```
Понятно, что то, что мы ставим в `catch` блок - все, что ниже по иерархии мы и ловим.
Соответственно надо понимать, что чем шире вы поставите свой *фильтр* - тем больше вы поймате исключений, поэтому надо задумываться - а надо ли вам ловить что-то конкретное или ловить более общее?

Небольшой тест - что будет выведено на экран при запуске данного куска кода?:
```java
public static void main(String[] args) {
        try {
            try {
                throw new Exception("0");
            } finally {
                if (true) {
                    throw new IOException("1");
                }
                System.err.println("2");
            }
        } catch (IOException ex) {
            System.err.println(ex.getMessage());
        } catch (Exception ex) {
            System.err.println("3");
            System.err.println(ex.getMessage());
        }
    }
```
Ответ:
Видим на выходе "1"!

###### Re-throw
Еще один момент, это так называемый `re-throw`.
Это когда вы перехватываете исключение в `catch` блоке, логируете, формируете там еще одно и выбрасываете уже его, возможно(почти обязательно) вкладывая предыдущее исключение в новое.
Как это выглядит на практике:
```java
try {
Reader readerConf = ....
readerConf.readConfig();
} catch(IOException ex) {
//logging error
throw new ComponentException(ex)
}
```
Мы перехватили ошибку чтения, обернули ее в новую ошибку, с более понятным названием и выкинули наверх.
Для чего это нужно? Это полезно для более гибкой обработки исключений, т.е неважно что стало с нашим конфигом(нет файла, нет какой-то строки) - мы формируем ошибку, что мы не можем работать с этим компонентом программы.
При этом, так как мы вложили перехваченное исключение в новое - в `stacktrace` будет развернуто написано что и где произошло.
Заметим, что мы могли бы еще снабдить новое исключение каким-нибудь сообщением, более подробно описывающим произошедшую ситуацию.

Часто бывает полезно перехватить `checked` исключение, залогировать его и выкинуть уже `unchecked`.
Т.е, например, вы понимате, что данное исключение критическое - вы его логируете и кидаете уже необрабатываемое исключение дальше, которое завершает ваше приложение. При этом вы получаете развернутую информацию о произошедшем и в лог-файле, и в `stacktrace`.

###### Throws
Есть еще одна возможность работать с исключениями - это `throws`, прокидывание исключения наверх.
Ключевое слово `throws` говорит о том, что данный метод *может* выбросить исключение.
Выглядит это как-то так:
```java
void method() throws IOException;
```
Т.е мы явно в сигнатуре метода указываем, что данный метод *может* выбросить проверяемое исключение `IOException`.
Таким образом мы можем не обрабатывать исключение внутри метода с помощью конструкций `try/catch/finally`, а поднять исключение выше и возложить обязанность обработки исключения на код, который уже будет непосредственно работать с данным методом.

Необязательно указывать в `throws` только проверяемые исключения, но прописывать непроверяемые нет смысла, потому что такие исключения не контролируются в `compile time`.

##### Собственные исключения
Полезно иногда иметь свою иерархию исключений.
Например, у нас есть `methodException()` и он кидает три разных `Exception`-а.

Имея свою иерархию(т.е три исключения, отнаследованных от `Exception`) - мы просто пишем три `catch` блока на каждое исключение и обрабатываем каждую ситуацию так, как нам надо.


Без этого у нас был бы только один `catch` блок с перехватом `Exception`, где мы уже бы уже как-то должны были понимать что мы за исключение вообще перехватили и как это исключение обрабатывать.

И еще одно:

В `Java` *можно* наследоваться от `Throwable`, однако это крайне не рекомендуется. Это правило.
В вашей иерархии исключений используйте `RuntimeException` и `Exception`.

##### Исключения в статическом блоке
Все исключения возникающие в статическом блоке оборачиваются в `ExceptionInInitializerError`, которое выбрасывается.
```java
public class ExceptionHandling3{
  static{
     throwRuntimeException();
  }
  private static void throwRuntimeException()  {
        throw new NullPointerException();
  }
  public static void main(String[] args)  {
        System.out.println("Hello World");
  }
}
```

Выведет:
```
java.lang.ExceptionInInitializerError Caused by: java.lang.NullPointerException at exception.test.ExceptionHandling3.throwRuntimeException(ExceptionHandling3.java:13) at exception.test.ExceptionHandling3. (ExceptionHandling3.java:8)
```
##### Исключения и наследование
//todo

Переопределяющий метод не должен бросать новое или более широкое исключение, однако он может ВООБЩЕ не бросать исключение!

##### Исключения и потоки
А что если возникает исключение в отдельном потоке исполнения?
Для примера рассмотрим следующий код:
```java
public class ExceptionHandling4 {
  public static void main(String[] args) throws InterruptedException {
    Thread t = new Thread() {
        @Override
        public void run() {
                throw new RuntimeException("Testing unhandled exception processing.");
         }
    };
    t.start();
  }
}
```
Т.е наше исключение прерывает поток исполнения(interrupt thread):
При исполнении данного кода выведется что-то подобное и ваше приложение завершится:
```
Exception in thread “Thread-0” java.lang.RuntimeException: Testing unhandled exception processing. at exception.test. ExceptionHandling4$1.run(ExceptionHandling4.java:27)
```
Что делать в таких ситуациях и как обрабатывать исключения?
Все просто используем `Thread.UncaughtExceptionHandler`.

```java
t.setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {
          public void uncaughtException(Thread t, Throwable e)   {
             System.out.println("Handled uncaught exception in thread :" + t + " Exception : " + e);
         }
  });
```

И вывод уже будет:
```
Handled uncaught exception in thread :Thread[Thread-0,5,main] Exception : java.lang.RuntimeException: Testing unhandled exception processing.
```

#### Вывод
* Используем проверяемые исключения в случае, когда мы понимаем, что тут может быть ошибка.
* Непроверяемые исключения - если это наша ошибка.
* Полезно иметь свою иерархию исключений.
* Используйте `finally` и `try-with-resources`, если работаете с ресурсами.
* `finally` блок отрабатывает всегда, даже если был `return`.
* Кидаем исключения с помощью `throw`.
* Поднять исключение выше -  `throws`.
* Все проверяемые исключения должны быть обработаны!
* `try-catch block`, как и обычный `try` -  **не транзакционный** - все объекты, которые создали в `try` *ДО* исключения остаются в памяти.
