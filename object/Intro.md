## java.lang.Object и все-все-все
### Введение
`Java` - это объектно-ориентированный язык программирования.
В этом ЯП мы оперируем классами и объектами.

И класс `java.lang.Object` является корнем иерархии классов в `Java`.
Каждый класс, **включая массивы**, является потомком `java.lang.Object` - прямым или косвенным.


Это значит, что все классы в `Java` так или иначе наследуют методы `java.lang.Object`.
Давайте посмотрим, какие методы есть, благодаря этому, в каждом классе.

Итак, внутри `java.lang.Object` у нас есть(на момент `Java 8`):
* `public String toString()`

* `protected native Object clone() throws CloneNotSupportedException`

* `public native int hashCode()`

* `public final native void wait(long timeout) throws InterruptedException`

* `public final native void notify()`

* `public final native void notifyAll()`

* `public boolean equals(Object obj)`

* `protected void finalize() throws Throwable `

* `public final native Class<?> getClass()`

Поговорим про каждый метод более подробно.

### toString()
Как можно догадаться из названия, данный метод позволяет получить некоторое строковое представление объекта, у которого он вызывается.
Если не переопределять данный метод, то строковое представление объекта будет результатом выполнения следующего кода:
```java
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```
Т.е по умолчанию результатом будет имя класса и его `hashCode` в hexadecimal представлении, разделенные символом `@`.

В `JavaDoc` рекомендуется этот метод переопределять.

[Подробнее про toString](./ToString.md)

### finalize()
Данный метод вызывается `GC` тогда, когда `GC` полагает, что объект более не нужен, никем не используется и его пора утилизировать.

> GC - Garbage Collector

В общем виде можно считать, что `GC` думает, что объект можно удалить, если на него не существует ссылок.
Но на самом деле все гораздо сложнее, существуют несколько стратегий поведения `GC` и все они сложнее, чем простой подсчет ссылок.

Однако, сейчас мы говорим все же про `finalize`!
И на первый взгляд, может показаться, что это отличный метод, в который хорошо поместить закрытие ресурсов и прочее, что нужно освобождать/удалять при уничтожении класса.
Но это очень обманчиво. Более того, использование `finalize` подвержено ошибкам и многие вообще считают, что использовать его - **неправильно**.

Почему?

Прежде всего потому что у нас нет **НИКАКИХ** гарантий, что этот метод вообще вызовется.

Это легко может произойти, если у нас где-то в коде есть забытая ссылка на объект - мы про ссылку ничего не знаем, но она существует и `GC` не будет удалять этот объект.
При этом существует вероятность, когда данный мтеод вообще вызван не будет - например, если наше приложение вдруг упадет или мы его остановим.


Еще одно **заблуждение**  - если мы в `finalize()` методе повесим процесс(ведь `GC` работает в фоне), то и наш `GC` перестанет работать.
Разумеется, это **не верно**.

И вот почему:

Наш `GC` не вызывает `finalize()` напрямую, а добавляет объекты в список, вызывая `java.lang.ref.Finalizer.register(Object)`.
Объект класса `java.lang.ref.Finalizer` представляет собой ссылку на объект, для которого надо вызвать `finalize()`, и хранит ссылки на следующий и предыдущий `Finalizer`, формируя двусвязный список.

Вызов `finalize()` происходит в отдельном потоке `java.lang.ref.Finalizer.FinalizerThread`, вызовы `finalize` идут последовательно так, как добавлялись. Поэтому, если `finalize` зависает - виснет именно `FinalizerThread`, если класс имеет пустой метод `finalize`, то объекты такого класса будут и дальше удаляться, если же метод не пуст - то добавляются в список и ждут, пока все не отвиснет или не упадет окончательно, либо мы вообще не завершим наше приложение.

Как выглядит `finalize()`:
```java
protected void finalize() throws Throwable { }
```

Как уже было сказано выше - в большинстве случаев не рекомендуется его переопределять и использовать в качестве очистки ресурсов и т.д.

Однако, в очень редких случаях - этот метод может помочь.
Это довольно специфичные случаи, но все же, давайте рассмотрим пример.

Например, у нас объект с `Weak/Soft References` и мы работаем с реально большим файлом. В какой-то момент нам не хватает памяти и `GC` начинает вычищать объекты по нашим ссылкам и убирает наш объект, но мы **ОБЯЗАНЫ** закрыть наш файловый дескриптор.

И вот в таком случае - переопределение метода поможет нам решить задачу с закрытием ресурсов.
Но стоит помнить, что тут мы имеем дело не со строгими ссылками и рассмотренный случай - скорее редкость.

### getClass()
Возвращает класс объекта, который содержит методы для определения свойств класса и получения информации о классе.
Например, мы можем получить имя класса, список объявленных методов и т.д

Сигнатура метода выглядит как:
```java
public final native Class<?> getClass();
```

Данный метод является финальным и переопределить его нельзя.

Как было сказано в самом начале - с его помощью мы получаем класс объекта, а значит можем использовать для `Reflection API`.

Для примера выведем имя класса:
```java
void printClassName(Object obj) {
    System.out.println("The object's" + " class is " +
        obj.getClass().getSimpleName());
}
```

### equals(Object obj)
Как можно догадаться из названия - метод используется для сравнения объектов.

В `Java` существует два вида сравнения объектов:
* Сравнение по ссылке
* Сравнение по значению

Сравнение по ссылке происходит тогда, когда вы используете оператор `==`.
Например:
```java
public class Test {
    public static void main(String[] args) {
        Car my = new Car();
        Car your = new Car();
        Car link = my;

        System.out.println(my == your);
        System.out.println(my == link);
    }
}

class Car {}
```

Ссылки `my` и `your` - указывают на разные объект, в то время как `link` - указывает на тот же объект, на который ссылается `my`.

Поэтому результат вызова этого кода будет:
```java
false
true
```

Однако чаще всего необходимо сравнение именно по значению, поэтому и ввели метод `equals`.

Данный метод сравнивает два объекта и возвращает `true` в случае их равенства и `false` в случае различия.

По умолчанию реализация этого мтеода выглядит так:
```java
public boolean equals(Object obj) {
        return (this == obj);
    }
```

Т.е по умолчанию данный метод проверяет на то, что проверяемая ссылка ссылается на этот же объект - происходит проверка равенства по ссылке.

Именно поэтому данный метод советуют переопределять.

Важно понимать, что так как в `Java` мы оперируем не только объектами, но и примитивными типами данных, такими как `int`, `long` и т.д, то сравнивать примитивные типы данных нужно через `==`.

Что на самом деле логично, учитывая как минимум то, что у примитивных типов данных нет никакого `equals` метода.

[Подробнее про equals](./Equals.md)

### hashCode()
Вызов метода `hashCode()` у объекта вернет нам целое число типа `int`.
Этот метод - это реализация hash-функции для `Java`-объекта. Это число в `Java` считается hash-кодом объекта.

Это `native`-метод, что означает, что метод реализован в платформенно-зависимом коде, чаще всего на `C/C++`, и скомпонован в виде динамической библиотеки.
Возможно, вас сейчас это напугало, но на самом деле достаточно просто понимать, что `native` означает лишь то, что мы вызываем код, который реализован не на `Java`.

> Важно помнить, что `native` модификатор применим только к **методам**, но не к классам или переменным.

При этом, `native`-методы вполне можно переопределять в `Java`, о чем пойдет речь ниже.

```java
 public native int hashCode();
```

Если вы планируете использовать объекты класса в `hash`-таблицах(в `Java` - в `Map`-ах), то вы **обязательно** переопределяйте данный метод, иначе вы не получите никаких преимуществ, которые дает `hash`-таблица. Подробнее об этом: //todo ссылка на статью о мапах

Контракт `hashCode` предъявляет следующие требования к реализации метода:
* Если вызвать метод `hashCode` на одном и том же объекте, состояние которого не меняли, то мы **обязаны** получить одно и то же значение.
* Если два объекта равны, то вызов `hashCode` для каждого **обязан** давать один и тот же результат.
> Равенство объектов проверяется через вызов метода `equals`.

* Если два объекта имеют один и тот же `hash`-код, то это не гарантирует равенства объектов.

Проще говоря, разный `hash`-код у двух объектов - это гарантия того, что объекты не равны, в то время как одинаковый `hash`-код не гарантирует равенства.
Такая ситуация, когда разные объекты имеют одинаковые `hash`-код, называется `collision` или коллизией.

> Логично, что коллизии возможны - так как размер `int` ограничен.

По умолчанию, метод `hashCode` возвращает разные значения `hash`-кодов для разных объектов.
Например:
```java
public class Test {
    public static void main(String[] args) {
        System.out.println(new A(4).hashCode());
        System.out.println(new A(4).hashCode());
    }
}

class A {
    private int a;

    public A(int a) {
        this.a = a;
    }
}
```
Получим два разных значния.

Это связан с тем, что `native` реализация метода `hashCode()` возвращает преобразование внутреннего адреса объекта в `int`.

Просто запомните, что `native` реализация для разных объетов возвращает разные значения `hash`-кодов, не взирая на состояние объекта.

[Подробнее о hashCode()](./Hashcode.md)

### clone()
И снова предназначение метода нам подскажет его название.
Данный метод задумывался разработчиками как простой и понятный способ создать копию объекта, его клон - отсюда и название.

Объявление метода выглядит так:
```java
protected native Object clone() throws CloneNotSupportedException;
```

Клонировать можно только те объекты, которые реализуют интерфейс `java.lang.Cloneable`.
Данный интерфейс является интерфейсом-марекром, как и `Serializable`.

Если объект не реализует интерфейс-маркер `java.lang.Cloneable`, то выбросится исключение `CloneNotSupportedException`.

Рассмотрим пример:
```java
public class CloneTest implements Cloneable {
    private final int i;

    public CloneTest(int i) {
        this.i = i;
    }

    public int getI() {
        return i;
    }

    public static void main(String[] args) throws CloneNotSupportedException {
        CloneTest test = new CloneTest(2);
        CloneTest cloneTest = (CloneTest) test.clone();
        System.out.println("Original : " + test + ", i = " + test.getI());
        System.out.println("Clone : " + cloneTest + ", i = " + cloneTest.getI());
    }
}
```

На первый взгляд может показаться, что все очень удобно и практично, однако использование `clone` также часто не рекомендуется, так как несет за собой большое количество узких мест и подводных камней.

[Подробнее про clone](./Clone.md)
