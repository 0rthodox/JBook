# SOLID

## Введение

Важным шагом к пониманию того, как писать правильный, аккуратный и чистый код является понимание принципов `SOLID`.

Итак, `SOLID` - это акроним, каждой букве соответствует свой принцип:

* S - SRP - Single responsibility principle
* O - OCP - Open closed principle
* L - LSP - Liskov substitution principle
* I - ISP - Interface segregation principle
* D - DIP - Dependency inversion principle

В полезных ссылках вы найдете примеры кода по каждому принципу.

### Single Responsibility Principle

> A class should have one, and only one, reason to change.

Класс должен иметь только одну причину для изменения.

Каждый объект должен иметь одну обязанность(ответственность за что-то) и эта обязанность должна быть полностью инкапсулирована в класс.

Следование этому принципу даст нам слабо связанное приложение, которое будет легко изменять и дорабатывать в дальнейшем.

Для примера возьмем сервис, который составляет и рассылает отчеты.

Если объединить все эти задачи в один класс, то такой класс будет иметь сразу несколько причин для изменения:

* Изменяется содержимое отчета
* Изменяется формат отчета
* Изменяется способ рассылки отчета

В таком случае, на класс возложено слишком много ответственности, а это чревато сложностями в изменнии класса в дальнейшем, в поддержке работоспособности кода, в гибкости использования и т.д.

`SRP` говорит как раз о том, что надо разнести такой класс на несколько, чтобы каждый класс занимался своей областью.

> Делегируйте ответственность!

И не забывайте: [KISS](https://ru.wikipedia.org/wiki/KISS_(%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF))!

### Open/Closed Principle

> Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification

Программные сущности(классы, модули, функции и т.д.) должны быть открыты для расширения, но закрыты для изменения.

Т.е класс должен быть закрыт к изменению извне, но при этом - должен иметь возможности к расширению реализации.

Например, у нас есть интерфейс `Personality` и класс `Greeter`:

```java
public interface Personality {
    public String greet();
}
```

И

```java
public class Greeter {
    private Personality personality;

    public Greeter(Personality personality) {
            this.personality = personality;
        }

    public String greet() {
        return personality.greet();
    }
}
```

Есть разные реализации `Personality`:

```java
public class FormalPersonality implements Personality {
    public String greet() {
        return "Good evening, sir.";
    }
}
````

или

```java
public class IntimatePersonality implements Personality {
    public String greet() {
        return "Hello Darling!";
    }
}
```

Наш класс `Greeter` открыт для расширения, мы можем передать любой другой `Personality`, в зависимости от задачи. При этом сам код `Greeter` не меняется: мы можем без изменения (перекомпиляции) модуля с логикой использовать различные способы приветствия.

Т.е классы и модули должны проектироваться так, чтобы для изменения их поведения, нам не нужно было изменять их исходный код.

В этом и состоит суть `OCP` принципа.

### Liskov Substitution Principle

Этот принцип имеет сложное математическое определение, которое можно заменить на:

> Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом.

Или, если совсем упростить:

> Объекты могут быть заменены их наследниками без изменения свойств программы.

В качестве примера можно взять классы `Прямоугольник` и `Квадрат`.

Класс `Прямоугольник` имеет методы, устанавливающие ширину и длину прямоуголника.

Мы наследуем  `Квадрат` от `Прямоугольника` и переопределяем методы так, что любое изменение длины длины изменяет также и ширину, и наоборот.

По сути - выставляем всегда одинаковые ширину и длину для класса `Квадрата`.

```java
class Rectangle {
    private int height;
    private int width;

    public void setHeight(int height) {
        this.height = height;
    }

    public void setWidth(int width) {
        this.width = width;
    }
}
class Square extends Rectangle {
    public void setHeight(int height) {
        this.height = height;
        this.width = height;
    }

    public void setWidth(int width) {
        this.width = width;
        this.height = width;
    }
}
```

Так вот это - **явное** нарушение `Liskov Substitution Principle`.

Мы нарушаем повдеение базового класса таким образом, так как вдруг почему-то меняется и длина, и ширина!

Получается, что вызывая метод установить длину для квадрата - мы таким образом наршуаем поведение прямоуголника.

### Interface Segregation Principle

> Many client-specific interfaces are better than one general-purpose interface.

Принцип разделения интерфейсов говорит о том, что слишком "толстые" интерфейсы необходимо разделять(разбивать) на более маленькие и более специфические, чтобы клиенты маленьких интерфейсов знали только о методах, которые необходимы им в работе.

В итоге, при изменении метода интерфейса не должны меняться клиенты, которые этот метод не используют.

Если у вас есть интерфейс `Report`, то не стоит туда вносить все возможные методы генерации отчета, например, `generatePdf`, `generateXml` и так далее.

Так как тогда всем потребуется реализовывать методы этого "толстого" интерфейса.

А большинству может вообще не понадобится `generateXml`!

Поэтому такой интерфейс лучше разбить на несколько, `XmlReport` и `PdfReport`, например.

Внимательный читатель должен уже провести аналогию с `SRP`!

### Dependency Inversion

> Depend on abstractions, not on concretions.

* Модули верхних уровней не должны зависеть от модулей нижних уровней. Оба типа модулей должны зависеть от абстракций.

* Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций.

Старайтесь, чтобы различные модули были автономными, и соединялись друг с другом с помощью абстракции.

> Модуль верхнего уровня - модуль, работающий с бизнес-логикой.
> Чем ближе модуль к вводу/выводу, тем ниже уровень модуля.
>
> Например, работа с БД - модуль более низкого уровня, чем модуль, работающий с бизнес-логикой пользователя.

Идея состоит в том, что разделяя уровни бизнес-логики и модули нижних уровней(например, работа с БД), вы в дальнейшем сможете поменять реализацию модуля нижнего уровня без изменения кода бизнес-логики.

Например, мы знаем, что будем использовать реляционную базу данных, и выбрали `PostgreSql`.

Но какая будет схема таблиц, какие будут индексы, и т.д. сейчас решить сложно. Разделяя бизнес-логику на разные уровни с реализацией модуля по работе с БД, мы как раз добьемся необходимой гибкости.

## Дополнение

Есть еще полезные принципы, о которых также следует поговорить.

### KISS

> Keep it simple, stupid.

`KISS` — это принцип проектирования и программирования, при котором простота системы декларируется в качестве основной цели или ценности.

Основной посыл `KISS` в том, что не имеет смысла реализовывать дополнительные функции и модули, которые не нужны или их использование крайне маловероятно.

Также, не стоит перегружать интерфейс теми опциями, которые не нужны большинству пользователей.

В простоте - сила.

Стоит отметить еще то, что надо опасаться неограниченно увеличивать уровень абстракции, надо уметь вовремя остановиться.

Не стоит закладывать избыточные функции "про запас".

Не стоит тянуть в зависимостях огромную библиотеку, если вам от неё нужна лишь пара функций.

Старайетсь декомпозировать сложную, большую задачу на простые составляющие.

### DRY

> Don’t repeat yourself.

Стоит избегать дублирования кода.

Если ваш код не дублируется, то его изменение и модификация будет происходить всегда в одном месте, что сократит количество ошибок, упростит тестирование и улучшит понимаение.

### YAGNI

> You aren't gonna need it.

Старайтесь избежать излишней абстракции, обходите стороной желания эксперимента "из интереса" и не делайте реализации функционала, который сейчас не нужен, но, по вашему мнению, может либо вскоре понадобиться, либо просто будет полезен.

В реальности такого очень часто не происходит и вы потратите кучу времени и сил зря.

## Полезные ссылки

Примеры кода по каждому принципу:

[SOLID Примеры](https://github.com/qcha/SOLID)

Принципы из дополнения:

1. [YAGNI](https://ru.wikipedia.org/wiki/YAGNI)
2. [KISS](https://ru.wikipedia.org/wiki/KISS_(%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF))
3. [DRY](https://ru.wikipedia.org/wiki/Don%E2%80%99t_repeat_yourself)
